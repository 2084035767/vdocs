# 算法

## 一. 算法基础

### 1.1 算法的定义和特性

## 算法的基本概念

程序 = 数据结构 + 算法

数据机构：如何把现实世界的问题信息化， 将信息存进计算机。同时还要实现对数据结构的基本操作

算法：如何处理这些信息，以解决实际问题

### 算法的特性

- 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。 注：算法必须是有穷的，而程序可以是无穷的
- 确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
- 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
  输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

### 好算法的特质

1. 正确性：算法应能够正确地解决求解问题。
2. 可读性：算法应具有良好的可读性，以帮助人们理解。
3. 健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 高效率与低存储量需求（执行速度快，时间复杂度低；不费内存，空间复杂度低）

## 算法效率的度量

### 算法的时间复杂度

算法时间复杂度(全称：渐进时间复杂度)：事前预估算法时间开销 T(n)与问题规模 n 的关系（T 表示“time”）

示例

```c
void love(int n) { //n 为问题规模
    int i = 1； //①爱的程度
    while (i<=n) { //②
        i++; //③
        printf("爱你%d\n",n); //④
    }
    printf("更爱你%d\n",n); //⑤
}
```

语句频度： 

① ——1 次 

② ——3001 次 

③④ ——3000 次 

⑤ ——1 次
T(3000) = 1 + 3001 + 2*3000 + 1 时间开销与问题规模 n 的关系：T(n)=3n+3

#### 思考

问题 1：是否可以忽略表达式 某些部分？

> 大 O 表示“同阶”，同等 数量级。即：当 n->∞时，二者之比为常数

结论 1：可以只考虑阶数高的部分

结论 2：问题规模足够大时， 常数项系数也可以忽略

> 加法规则：多项相加，只保留最高阶的项，且系数变为 1
>
> T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
>
> 乘法规则：多项相乘，都保留
>
> T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n))

需要记住的常见复杂度（时间和空间同样适用）：常对幂指阶

O(1) < O(log~2~n) < O(n) < O(nlog~2~n) < O(n^2^) < O(n^3^) < O(2^n^) < O(n!) < O(n^n^)

----

问题 2：如果有好几千行代码， 按这种方法需要一行一行数？

结论 1：顺序执行的代码只会 影响常数项，可以忽略
结论 2：只需挑循环中的一个 基本操作分析它的执行次数 与 n 的关系即可
结论 3：如果有多层嵌套循环，只需关注最深层循环循环了几次

#### 三种复杂度

- 最坏时间复杂度：最坏情况下算法的时间复杂度 
- 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间
- 最好时间复杂度：最好情况下算法的时间复杂度

### 算法的空间复杂度

空间复杂度：空间开销（内存开销）与 问题规模 n 之间的关系（S 表示“Space”）

算法原地工作——==算法所需内存空间为常量==

实例

```c
void test(int n) {
    int flag[n]; //声明一个长度为n的数组
    int i;
    //省略代码
}
```

- 程序代码：大小固定，与 问题规模无关
- 数据：局部变量 i， 参数 n ……数组 flag[n] ……等

假设一个 int 变量占 4B…… 则所需内存空间 = 4 + 4n + 4 = 4n + 8

（只需关注存储空间大小 与问题规模相关的变量）

空间开销（内存开销）与 问题规模 n 之间的关系：S(n) = O(n)

#### 函数递归调用带来的内存开销

代码

```c
void love(int n) { //n 为问题规模
    int a, b, c； // 声明一系列局部变量
    // ...省略代码    
    if (n > 1) {
        love(n - 1);
    }
    printf("爱你%d\n",n); 
}

int main(){
    love(5);
}
```

S(n) = O(n) ==空间复杂度 = 递归调用的深度==

### 1.2 算法设计的原则
### 1.3 算法分析和评估方法

## 二、基本算法思想

### 贪心算法

##### 活动选择问题 (Activity Selection Problem)

##### 零钱找零问题 (Coin Change Problem)

##### 背包问题的贪心解法

##### 哈夫曼编码 (Huffman Coding)

### 分治算法

### 动态规划

##### 背包问题 (Knapsack Problem)

##### 最长公共子序列 (Longest Common Subsequence)

##### 最短编辑距离 (Shortest Edit Distance)

##### 最优二叉搜索树 (Optimal Binary Search Tree)

##### 切割钢条问题 (Cutting Rod Problem)

### 回溯算法



## 三、排序算法

### 3.1 冒泡排序 (Bubble Sort)

### 3.2 选择排序 (Selection Sort)

### 3.3 插入排序 (Insertion Sort)

### 3.4 快速排序 (Quick Sort)
### 3.5 归并排序 (Merge Sort)

### 3.6 堆排序 (Heap Sort)

## 四、搜索算法

### 4.1 线性搜索 (Linear Search)

### 4.2 二分搜索 (Binary Search)

### 4.3 广度优先搜索 (Breadth-First Search)
### 4.4 深度优先搜索 (Depth-First Search)

## 五、字符串匹配算法

### 8.1 暴力匹配算法 (Brute Force)
### 8.2 KMP算法
### 8.3 Boyer-Moore算法
### 8.4 Rabin-Karp算法

## 六、算法技巧
