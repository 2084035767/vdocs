# 第二章:算法复杂度分析

## 2.1 时间复杂度

### 大 O 表示法

假设问题的规模为 n，则程序的时间复杂度表示为 `T(n)`。**代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**。

当 n 增大时，T(n) 也随之增大，想要准确估计其变化比较困难。所以，可以采用大 O 时间复杂度来粗略估计其复杂度，其表达式为：**`T(n) = O(f(n))`**。

**大 O 表示法**实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。

相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？

- **时间复杂度能够有效评估算法效率**
- **时间复杂度的推算方法更简便**
- **时间复杂度也存在一定的局限性**



### 时间复杂度分析的要点

- **只关注循环执行次数最多的一段代码**
- **加法法则：总复杂度等于量级最大的那段代码的复杂度**
- **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**





### 常见类型

常数阶 $O(1)$<对数阶 $O(logn)$<线性阶 $O(n)$< 线性对数阶 $O(nlogn)$<平方阶 $O(n^2)$<指数阶 $O(2^n)$<阶乘阶 $O(n!)$



[![](https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_common_types.png)](https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_common_types.png)

| 阶                   | 说明                                                         | 例子                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 常数阶 O(1)          | 常数阶的操作数量与输入数据大小 n 无关，即不随着 n 的变化而变化。 |                                                              |
| 线性阶 O(n)          | 线性阶的操作数量相对于输入数据大小 n 以线性级别增长。        | 线性阶通常出现在单层循环中，如遍历数组和遍历链表等操作       |
| 平方阶 O(n^2)        | 平方阶的操作数量相对于输入数据大小 n 以平方级别增长。        | 平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 O(n)，因此总体的时间复杂度为 O(n^2) 如冒泡排序等 |
| 指数阶 O(2^n)        | 生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推。 | 指数阶常出现于递归函数中。指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。 |
| 对数阶 O(log n)      | 与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。由于每轮缩减到一半，因此循环次数是 2^n 的反函数。 | 与指数阶类似，对数阶也常出现于递归函数中。对数阶常出现于基于分治策略的算法中。 |
| 线性对数阶O(n log n) | 线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(log⁡n) 和 O(n) 。 | 主流排序算法的时间复杂度通常为线性对数阶，例如快速排序、归并排序、堆排序等。 |
| 阶乘阶O(n!)          | 阶乘阶对应数学上的“全排列”问题。给定 n 个互不重复的元素，求其所有可能的排列方案 | 阶乘通常使用递归实现。阶乘阶比指数阶增长得更快，在 n 较大时也是不可接受的。 |





## 2.2 空间复杂度

「空间复杂度 space complexity」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。

### 算法相关空间

算法在运行过程中使用的内存空间主要包括以下几种。

- **输入空间**：用于存储算法的输入数据。
- **暂存空间**：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
- **输出空间**：用于存储算法的输出数据。

一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。

暂存空间可以进一步划分为三个部分。

- **暂存数据**：用于保存算法运行过程中的各种常量、变量、对象等。
- **栈帧空间**：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
- **指令空间**：用于保存编译后的程序指令，在实际统计中通常忽略不计。

在分析一段程序的空间复杂度时，**我们通常统计暂存数据、栈帧空间和输出数据三部分,在递归函数中，需要注意统计栈帧空间**。

### 常见类型

常数阶 $O(1)$<对数阶 $O(logn)$<线性阶 $O(n)$< 线性对数阶 $O(nlogn)$<平方阶 $O(n^2)$<指数阶 $O(2^n)$<阶乘阶 $O(n!)$

[![](https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_common_types.png)](https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_common_types.png)

| 阶              | 说明                                                      | 例子                                                         |
| --------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| 常数阶 O(1)     | 常数阶常见于数量与输入数据大小 n 无关的常量、变量、对象。 | 需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 O(1) ： |
| 线性阶 O(n)     |                                                           | 线性阶常见于元素数量与 n 成正比的数组、链表、栈、队列等：    |
| 平方阶 O(n^2)   |                                                           | 平方阶常见于矩阵和图，元素数量与 n 成平方关系：              |
| 指数阶 O(2^n)   |                                                           | 指数阶常见于二叉树。                                         |
| 对数阶 O(log n) |                                                           | 对数阶常见于分治算法。                                       |



## 2.3 最坏情况与平均情况分析

**算法的时间效率往往不是固定的，而是与输入数据的分布有关**。

- **最好情况时间复杂度**（best case time complexity）：**在最理想的情况下，执行代码的时间复杂度**。例如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，此时最好情况时间复杂度为 1。用 Ω 记号表示
- **最坏情况时间复杂度**（worst case time complexity）：**在最糟糕的情况下，执行代码的时间复杂度**。例如：在最理想的情况下，要查找的变量 x 正好是数组的最后个元素，此时最好情况时间复杂度为 n。使用大 O 记号表示。
- **平均情况时间复杂度**（average case time complexity）：平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。用 Θ 记号来表示。

值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。**而最差时间复杂度更为实用，因为它给出了一个效率安全值**，让我们可以放心地使用算法。
