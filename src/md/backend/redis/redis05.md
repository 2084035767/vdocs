# 五、Redis性能优化

## 5.1 内存优化



1. 内存消耗

1、内存使用统计

Redis 可以通过 info memory 命令来查看内存使用情况，属性说明如下：

<table><thead><tr><th align="left">属性名</th><th align="left">属性说明</th></tr></thead><tbody><tr><td align="left">used_memory</td><td align="left">Redis 分配器分配的内存量，也就是实际存储数据的内存总量</td></tr><tr><td align="left">used_memory_human</td><td align="left">以可读格式返回 Redis 使用的内存总量</td></tr><tr><td align="left">used_memory_rss</td><td align="left">从操作系统的角度，Redis 进程占用的总物理内存</td></tr><tr><td align="left">used_memory_peak</td><td align="left">内存分配器分配的最大内存，代表 used_memory 的历史峰值</td></tr><tr><td align="left">used_memory_peak_human</td><td align="left">以可读的格式显示内存消耗峰值</td></tr><tr><td align="left">used_memory_lua</td><td align="left">Lua 引擎所消耗的内存</td></tr><tr><td align="left">mem_fragmentation_ratio</td><td align="left">used_memory_rss/used_memory 比值，表示内存碎片率，used_memory_rss - used_memory 就是内存碎片的大小</td></tr><tr><td align="left">mem_allocator</td><td align="left">Redis 所使用的内存分配器，默认 jemalloc</td></tr></tbody></table>

2、内存消耗划分

used_memory,Redis 分配器分配的内存量 自身内存 800K 左右 对象内存 key 对象 value 对象 缓冲内存 客户端缓冲区 复制缓冲区 AOF 缓冲区 Lua 内存

2. 缓冲内存

### 1. 客户端缓冲区

客户端分为普通客户端（Jedis）、slave 客户端、pubsub 客户端。

输入缓冲区：

流程：客户端 -> 命令（输入缓冲区） -> 处理命令

注意：最大 1GB，超过后会被强制断开，不可动态设置。

输出缓冲区：

输出缓冲区对应的配置规则是：client-output-buffer-limit <class> < hard limit> < soft limit> < soft seconds>

<class>：客户端类型，分为三种（a）normal 普通客户端；（b）slave 从节点用于复制，伪装成客户端；（c）pubsub 发布订阅客户端。  
<hard limit>：如果客户端使用的输出缓冲区大于 < hard limit>，客户端会被立即关闭。  
<soft limit> 和 < soft seconds>：如果客户端使用的输出缓冲区超过了 < soft limit> 并且持续了 < soft limit> 秒，客户端会被立即关闭。

普通客户端（Jedis）默认 client-output-buffer-limit normal 0 0 0，默认没有限制客户端缓冲，注意防止大的命令或者 monitor。  
slave 客户端默认 client-output-buffer-limit slave 256mb 64mb 60，注意从节点不要超过 2 个。  
pubsub 客户端默认 client-output-buffer-limit pubsub 32mb 8mb 60，使用场景并不多，注意根据实际场景适当调试。

### 2. 复制缓冲区

此部分内存独享，考虑部分复制，默认 1 MB，可以设置更大。

### 3.AOF 缓冲区

AOF 重写期间，AOF 的缓冲区没有容量限制。

3. 对象内存

key 对象：不要过长，量大不容忽视；  
value 对象：ziplist、intset 等优化方式。

4. 内存管理

### 1. 内存设置上限

定义实例最大内存，便于管理机器内存，一般要预留 30%。动态调整内存上限的命令：

```
redis> config set maxmemory 6GB
	redis> config rewrite
```

### 2. 内存回收策略

1、删除过期键值

惰性删除：访问 key -> expired dict -> del key  
定时删除：每秒运行 10 次，采样删除。

2、内存溢出控制策略

超过 maxmemory 后触发相应策略，由 maxmemory-policy 控制。

*   Noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回错误信息 “(error) OOM command not allowed when used memory”，此时 Redis 只响应读操作由 maxmemory-policy 控制。
*   Volatile-lru：根据 LRU 算法删除设置了超时属性（expire）的键，直到腾出足够空间为止，如果没有可删除的键对象，回退到 Noeviction 策略。
*   Allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
*   Allkeys-random：随机删除所有键，直到腾出足够空间为止。
*   Volatile-random：随机删除过期键，直到腾出足够空间为止。
*   Volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期的数据，如果没有，回退到 Noeviction 策略。

5. 内存优化

1、合理的选择优化数据结构

2、客户端缓冲区内存优化

示例：一次内存暴增。Redis [Sentinel](https://so.csdn.net/so/search?q=Sentinel&spm=1001.2101.3001.7020) 架构，maxmemory 设置为 4GB，发现主节点使用内存 4GB，从节点使用内存 2GB。

排查过程：主节点是否有大批量的写入？查看监控发现没有。  
主从不一致？主从都执行 dbsize 命令，发现都是 23254136。  
客户端溢出？实际上已经收到报警了，最大输出缓冲区溢出了，这个时候我们完全可以使用 client list 命令找到 omem 为 0 的客户端连接：

```
redis-cli client list | grep -v "omem=0"
```

发现有一个 oll=201261 omem=4675586842 cmd=monitor 的连接，根据 cmd==monitor 判断执行来源是 monitor，monitor 拉取了那么大数据，但是自身消费不了，这个时候我们可以将 monitor 直接干掉，进行内存回收。

预防策略：

*   运维层面：线上 Redis 禁用 monitor（rename-command）命令；适度限制缓冲区大小；
*   开发层面：理解 monitor 原理，也可以短暂寻找热点 key（本地执行）；使用 CacheCloud 可以直接监控到。

3、其他方法

*   不要忽视 key 的长度，1 亿个键，1 个字节也是节省；
*   序列化和压缩方法，拒绝 java 原生，采用 protobuf、keyo、snappy 等。

## 5.2 缓存优化

**服务器高可用的问题**

Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。

### 缓存穿透

#### 概念

缓存查不到，导致数据都查数据库

缓存穿透的概念很简单，用户想要查询一个数据，发现 redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。|

#### 解决方案

##### 布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力

##### 缓存空对象

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源;

但是这种方法会存在两个问题: 1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键; 2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。

### 缓存击穿

#### 概述

全都查缓存，此时缓存恰好过期，导致量过大

这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期 ，会同时访问数据库来查询最新数 据，并且回写缓存，会导使数据库瞬间压力过大。

#### 解决方案

##### 设置热点数据永不过期

从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。

##### 加互斥锁

分布式锁 ∶ 使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。

### 缓存雪崩

#### 概述

指在某一个时间段，缓存集中过期失效。Redis 宕机!

产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。

### 基本解决方案

redis 高可用 这个思想的含义是，既然 redis 有可能挂掉，那我多增设几台 redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活!) 限流降级（在 SpringCloud 讲解过!) 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

## 5.3 持久化优化

在高性能的数据存储领域，Redis是一个备受青睐的选择。然而，Redis的持久化机制在处理大量数据时可能会面临磁盘IO瓶颈的问题。本文将探讨一些优化策略，帮助减轻Redis持久化对磁盘IO的负担，提高存储性能。

1. 选择适当的持久化方式

Redis提供了两种主要的持久化方式：RDB和AOF。RDB是一种快照机制，将Redis的内存数据定期保存到磁盘上的二进制文件中。AOF（Append-Only File）则是将Redis的写操作追加到文件末尾，以此来记录所有的写操作。在选择持久化方式时，需要根据具体的应用场景和需求来进行权衡。

如果对数据的完整性要求较高，可以选择AOF方式。但是，AOF方式会产生大量的写操作，对磁盘IO造成较大的压力。如果对数据的一致性要求较高，可以选择RDB方式，在恢复数据时可以更快速。

1. 调整持久化频率

在Redis的配置文件中，可以通过设置save参数来调整RDB持久化的频率。默认配置为save 900 1，表示在900秒（15分钟）内，如果至少有1个键发生改变，则执行RDB持久化操作。这个时间间隔可以根据实际情况进行调整。

如果对数据的实时性要求较高，可以适当减小持久化频率。但是需要注意的是，频繁的持久化操作会增加磁盘IO的负担，可能会影响Redis的性能。因此，需要根据实际需求和硬件资源来进行权衡。

1. 合理配置AOF缓冲区

在Redis的配置文件中，可以通过设置appendfsync参数来配置AOF的同步策略。默认配置为appendfsync everysec，表示每秒钟将AOF缓冲区的数据同步到磁盘上。这个同步策略可以根据实际需求进行调

## 5.4 高可用

**1. Redis 集群简介**
-----------------

### **1.1 什么是 Redis 集群**

Redis 集群是一种通过将多个 Redis 节点连接在一起以实现高可用性、数据分片和负载均衡的技术。它允许 Redis 在不同节点上同时提供服务，提高整体性能和可靠性。根据搭建的方式和集群的特性，Redis 集群主要有三种模式：主从复制模式（Master-Slave）、哨兵模式（Sentinel）和 Cluster 模式。

### **1.2 Redis 集群的作用和优势**

1.  **高可用性**：Redis 集群可以在某个节点发生故障时，自动进行故障转移，保证服务的持续可用。
2.  **负载均衡**：Redis 集群可以将客户端请求分发到不同的节点上，有效地分摊节点的压力，提高系统的整体性能。
3.  **容灾恢复**：通过主从复制或哨兵模式，Redis 集群可以在主节点出现故障时，快速切换到从节点，实现业务的无缝切换。
4.  **数据分片**：在 Cluster 模式下，Redis 集群可以将数据分散在不同的节点上，从而突破单节点内存限制，实现更大规模的数据存储。
5.  **易于扩展**：Redis 集群可以根据业务需求和系统负载，动态地添加或移除节点，实现水平扩展。

通过了解 Redis 集群的概念和优势，接下来将详细介绍三大集群模式的原理、配置、优缺点以及应用场景。

**2. 主从复制模式（Master-Slave）**
---------------------------

### **2.1 主从复制原理**

主从复制是 Redis 的一种基本集群模式，它通过将一个 Redis 节点（主节点）的数据复制到一个或多个其他 Redis 节点（从节点）来实现数据的冗余和备份。

主节点负责处理客户端的写操作，同时从节点会实时同步主节点的数据。客户端可以从从节点读取数据，实现读写分离，提高系统性能。

### **2.2 主从复制配置和实现**

*   **配置主节点**：在主节点的 redis.conf 配置文件中，无需进行特殊配置，主节点默认监听所有客户端请求。

```
# 主节点默认端口号6379
port 6379
```

*   **配置从节点**：在从节点的 redis.conf 配置文件中，添加如下配置，指定主节点的地址和端口：

```
# 从节点设置端口号6380
port 6380

# replicaof 主节点IP 主节点端口
replicaof 127.0.0.1 6379

 或者，通过Redis命令行在从节点上执行如下命令：
 redis> replicaof 127.0.0.1 6379
```

*   **验证主从复制**：在主节点上执行写操作，然后在从节点上进行读操作，检查数据是否一致。  

### **2.3 主从复制的优缺点**

**优点**：

1.  配置简单，易于实现。
2.  实现数据冗余，提高数据可靠性。
3.  读写分离，提高系统性能。

**缺点**：

1.  主节点故障时，需要手动切换到从节点，故障恢复时间较长。
2.  主节点承担所有写操作，可能成为性能瓶颈。
3.  无法实现数据分片，受单节点内存限制。

### **2.4 主从复制场景应用**

主从复制模式适用于以下场景：

1.  数据备份和容灾恢复：通过从节点备份主节点的数据，实现数据冗余。
2.  读写分离：将读操作分发到从节点，减轻主节点压力，提高系统性能。
3.  在线升级和扩展：在不影响主节点的情况下，通过增加从节点来扩展系统的读取能力。

总结：主从复制模式适合数据备份、读写分离和在线升级等场景，但在主节点故障时需要手动切换，不能自动实现故障转移。如果对高可用性要求较高，可以考虑使用哨兵模式或 Cluster 模式。

**3. 哨兵模式（Sentinel）**
---------------------

### **3.1 哨兵模式原理**

哨兵模式是在主从复制基础上加入了哨兵节点，实现了自动故障转移。哨兵节点是一种特殊的 Redis 节点，它会监控主节点和从节点的运行状态。当主节点发生故障时，哨兵节点会自动从从节点中选举出一个新的主节点，并通知其他从节点和客户端，实现故障转移。

### **3.2 哨兵模式配置和实现**

1.  **配置主从复制**：首先按照主从复制模式的配置方法，搭建一个主从复制集群（上面已经讲过）。  

2.  **配置哨兵节点**：在哨兵节点上创建一个新的哨兵配置文件（如：sentinel.conf），并添加如下配置：

```
# sentinel节点端口号
port 26379

# sentinel monitor 被监控主节点名称 主节点IP 主节点端口 quorum
sentinel monitor mymaster 127.0.0.1 6379 2

# sentinel down-after-milliseconds 被监控主节点名称 毫秒数
sentinel down-after-milliseconds mymaster 60000

# sentinel failover-timeout 被监控主节点名称 毫秒数
sentinel failover-timeout mymaster 180000
```

*   其中，`quorum`是指触发故障转移所需的最小哨兵节点数。`down-after-milliseconds`表示主节点被判断为失效的时间。`failover-timeout`是故障转移超时时间。  
    为什么只配置了 sentinel 监控主节点，没有配置监控从节点？ 因为通过主节点，就可以找到从节点。  

    

1.  **启动哨兵节点**：使用如下命令启动哨兵节点：

```
redis> redis-sentinel /path/to/sentinel.conf
```

1.  **验证哨兵模式**：手动停止主节点，观察哨兵节点是否自动选举出新的主节点，并通知其他从节点和客户端。  

### **3.3 哨兵模式的优缺点**

**优点**：

1.  自动故障转移，提高系统的高可用性。
2.  具有主从复制模式的所有优点，如数据冗余和读写分离。

**缺点**：

1.  配置和管理相对复杂。
2.  依然无法实现数据分片，受单节点内存限制。

### **3.4 哨兵模式场景应用**

哨兵模式适用于以下场景：

1.  高可用性要求较高的场景：通过自动故障转移，确保服务的持续可用。
2.  数据备份和容灾恢复：在主从复制的基础上，提供自动故障转移功能。

总结：哨兵模式在主从复制模式的基础上实现了自动故障转移，提高了系统的高可用性。然而，它仍然无法实现数据分片。如果需要实现数据分片和负载均衡，可以考虑使用 Cluster 模式。

**4. Cluster 模式**
-----------------

### **4.1 Cluster 模式原理**

Cluster 模式是 Redis 的一种高级集群模式，它通过数据分片和分布式存储实现了负载均衡和高可用性。在 Cluster 模式下，Redis 将所有的键值对数据分散在多个节点上。每个节点负责一部分数据，称为槽位。通过对数据的分片，Cluster 模式可以突破单节点的内存限制，实现更大规模的数据存储。

### **4.2 数据分片与槽位**

Redis Cluster 将数据分为 16384 个槽位，每个节点负责管理一部分槽位。当客户端向 Redis Cluster 发送请求时，Cluster 会根据键的哈希值将请求路由到相应的节点。具体来说，Redis Cluster 使用 CRC16 算法计算键的哈希值，然后对 16384 取模，得到槽位编号。

### **4.3 Cluster 模式配置和实现**

1.  **配置 Redis 节点**：为每个节点创建一个 redis.conf 配置文件，并添加如下配置：

```
# cluster节点端口号
port 7001

# 开启集群模式
cluster-enabled yes

# 节点超时时间
cluster-node-timeout 15000
```

像这样的配置，一共需要创建 6 个，我们做一个三主三从的集群。

1.  **启动 Redis 节点**：使用如下命令启动 6 个节点：

```
redis> redis-server redis_7001.conf
```

1.  **创建 Redis Cluster**：使用 Redis 命令行工具执行如下命令创建 Cluster：

```
redis> redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1
```

1.  **cluster-replicas** 表示从节点的数量，1 代表每个主节点都有一个从节点。  

2.  **验证 Cluster 模式**：向 Cluster 发送请求，观察请求是否正确路由到相应的节点。  

### **4.4 Cluster 模式的优缺点**

**优点**：

1.  数据分片，实现大规模数据存储。
2.  负载均衡，提高系统性能。
3.  自动故障转移，提高高可用性。

**缺点**：

1.  配置和管理较复杂。
2.  一些复杂的多键操作可能受到限制。

### **4.5 Cluster 模式场景应用**

Cluster 模式适用于以下场景：

1.  大规模数据存储：通过数据分片，突破单节点内存限制。
2.  高性能要求场景：通过负载均衡，提高系统性能。
3.  高可用性要求场景：通过自动故障转移，确保服务的持续可用。

总结：Cluster 模式在提供高可用性的同时，实现了数据分片和负载均衡，适用于大规模数据存储和高性能要求的场景。然而，它的配置和管理相对复杂，且某些复杂的多键操作可能受到限制。

**5. 总结**
---------

本文详细介绍了 Redis 的三大集群模式：主从复制、哨兵模式和 Cluster 模式。每种模式都有其特点和应用场景，具体如下：

1.  **主从复制模式**：适用于数据备份和读写分离场景，配置简单，但在主节点故障时需要手动切换。
2.  **哨兵模式**：在主从复制的基础上实现自动故障转移，提高高可用性，适用于高可用性要求较高的场景。
3.  **Cluster 模式**：通过数据分片和负载均衡实现大规模数据存储和高性能，适用于大规模数据存储和高性能要求场景。

在实际应用中，可以根据系统的需求和特点选择合适的 Redis 集群模式，以实现高可用性、高性能和大规模数据存储等目标。



