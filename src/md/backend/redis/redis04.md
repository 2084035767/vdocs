# 四、Redis高级特性

## 4.1 发布/订阅（Pub/Sub）

Redis 发布订阅(publsub)是一种消息通信模式 ∶ 发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。 订阅/发布消息图︰

第一个：消息发布者，第二个频道（消息队列），第三个：消息订阅者



### 测试

订阅端

```javascript
SUBSCRIBE kuizuo # 创建频道
```



发送端

```javascript
PUBLISH kuizuo ‘hello‘
```

使用场景：

1、实时消息系统，公告

2、实时聊天（将频道当做聊天室，将信息回显给所有人）

3、订阅，关注系统都是可以的







## 4.2 事务（Transaction）

Redis 单条命令式保存原子性的，但是事务不保证原子性!

Redis 事务本质： 一组命令的集合！一个事务中的所有命令都会被序列化，会安卓顺序执行

一次性、顺序性、排他性！执行一些列的命令！

Redis 事务没有隔离级别的概念！

所有命令在事务中并没有直接呗执行！而只有发起执行命令的时候才会执行！Exec

- 开始事务（multi）
- 命令入队（...）
- 执行事务（exec）

```bash
multi

set k1 v1
set k2 v2

get k1

exec  # 执行事务

DISCARD # 取消事务 事务队列中的命令都不会被执行

# 代码有问题，命令有错，事务中所有命令都不会被执行
# 运行中异常，执行其他命令正常，错误命令抛出异常
```

## 4.4 持久化

redis 是内存数据库,单如果不将内存中的数据库状态保存的磁盘,一旦服务器进程退出,服务器中的数据库状态也会丢失,所以 redis 提供了持久化的功能

### RDB(Redis Database)

在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是 Snapshot 快照,恢复时直接将快照文件读到内存

Redis 会单独创建 ( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何 IO 操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。我们默认的就是 RDB，一般情况下不需要修改这个配置!

**rdb 保存的文件是 dump.rdb**

dbfilename dump.rdb

#### 触发机制

1、save 的规则满足的情况下，会自动触发 rdb 规则

2、执行 flushall 命令，也会触发我们的 rdb 规则!

3、退出 redis，也会产生 rdb 文件!

就会自动生成一个 dump.rdb，有时候还有备份一份

#### 恢复 rdb 文件

只需要将 rdb 文件放在 redis 启动目录下就可以了,redis 启动的时候就会自动检查 dump.rdb 文件

```javascript
config get dir
"dir"
"/usr/local/bin" # 如果在这个目录下存在dump.rdb 启动就会自动恢复其中的数据
```



优点:

1、适合大规模的数据恢复

2、对数据的完整性要求不高

缺点：

1、需要一定的时间间隔进程操作，如果 redis 意外宕机了，这个最后一次修改数据就没有了

2、fork 进程的时候，会占用一定的内存空间

### AOF（Append Only File）

将我们的所有命令都记录下来，history，恢复的时候就把这个文件内的命令全部在执行一遍

默认是不开启的，我们需要手动进行配置!我们只需要将 appendonly 改为 yes 就开启了 aof !重启

redis 就可以生效了

如果这个 aof 文件有错误，这时候 redis 是启动不起来的，我们需要修复这个 aof 文件，redis 给我们提供了一个工具 redis-check-aof --fix

优点

可指定修改都同步还是每秒都同步，文件完整性会更好

缺点:

相对于数据文件，aof 远远大于 rdb，修复的速度也不如 rdb

Aof 的运行效率也要比 rdb 慢。

### 小结

只做缓存，如果你只希望你的数据在服务器运行的时候存在，也可以不使用任何持久化



## 4.3 主从复制

### 概念[](#概念)

主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower);数据的复制是单向的，只能由主节点到从节点。Master 以写为主，Slave 以读为主。 默认情况下，每台 Redis 服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

### 主从复制的作用主要包括︰[](#主从复制的作用主要包括)

1、数据冗余 ∶ 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 2、故障恢复︰当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。 3、负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。 4、高可用基石 ∶ 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。

一般来说，要将 Redis 运用于工程项目中，只使用一台 Redis 是万万不能的

原因如下︰ 1、从结构上，单个 Redis 服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大; 2、从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有内存用作 Redis 存储内存，一般来说，**单台 Redis 最大使用内存不应该超过 20G。**

主从复制，读写分离！80%的情况下都是在进行读操作，就可以减缓服务器压力，架构中经常使用，一主二从

### 环境配置[](#环境配置)

```javascript
redis:0>info replication  # 查看当前库信息
"# Replication
role:master  # 角色
connected_slaves:0 # 没有从机
master_replid:d6950e2fdb86b591f42e8725279034303e8cb6ee
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
```



需要修改 配置文件

端口 pid 名字 log 文件名 dump.rdb 名

### 一主二从[](#一主二从)

默认情况下，每台 Redis 服务器都是主节点;我们一般情况下只用配置从机就好了!认老大!一主（ 79)二从( 80，81 )

```javascript
SLAVEOF 127.0.0.1 6379 # 找谁为主机
```



**主机可以写，从机不能写只能读！**主机中的所有数据都会被从机保存

主机断开连接，从机依旧可以连接到主机，并且主机回来，从机依旧可以直接获取数据

从机重新连接会主机，主机的任何操作立马同步到从机上

### 复制原理[](#复制原理)

slave 启动成功连接到 master 后会发送一个 sync 命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，**master 将传送整个数据文件到 slave，并完成一次完全同步。**

全量复制：slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。

增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步但是只要是重新连接 master，一次完全同步（全量复制)将被自动执行

### 层层链路[](#层层链路)

上一个 M 链接下一个 S





## 4.4 哨兵模式

### 概述[](#概述)

如果主机宕机了，从机要当主机，通过命令`SLAVEOF no one` 从机变主机，但如果这时候主机恢复了，那么就需要重新配置了，十分麻烦

主从切换技术的方法是 ∶ 当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis 从 2.8 开始正式提供了 Sentinel (哨兵）架构来解决这个问题。

后台能够监控主机是否故障，如果故障了根据投票数自动将从机变为主机

### 实现[](#实现)

哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是**哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。**



### 配置[](#配置)

1、哨兵配置文件 sentinel.conf

```javascript
sentinel monitor myredis 127.0.0.1 6379 1
```



后面的这个数字 1，代表主机挂了，slave 投票看让谁当主机，票数多的就会成为主机

2、启动哨兵

```javascript
redis-sentinel config/sentinel.conf
```



3、主机挂了，从机当主机了，但是如果原主机恢复了，也只能乖乖当新主机的从机

优点: 1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有

2、主从可以切换，故障可以转移，系统的可用性就会更好

3、哨兵模式就是主从模式的升级，手动到自动，更加健壮

缺点:

1、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦

2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择

## 4.5 监控 Watch

悲观锁：很悲观，认为什么时候都会出问题，无论做什么都会加锁

乐观锁：很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候判断一下，在此期间是否有人修改过该数据

```javascript
set money 100
set out 0

watch money

multi

DECRBY money 20
InCRBY money 20

# 如果这时用户充钱了 那么exec就无法执行
exec

# 解除监控，并重新监控最新的值
unwatch money
watch money
```

