# 常用工具类

目录

*   [springBoot 项目中常用工具类](#springboot项目中常用工具类)
    *   [一、RedisUtils](#一redisutils)
    *   [二、JwtUtil](#二jwtutil)
    *   [三、Result](#三result)
    *   [四、HttpUtils](#四httputils)

一、RedisUtils
------------

*   导入依赖

```xml
	 <dependency>

	      <groupId>org.springframework.boot</groupId>

	      <artifactId>spring-boot-starter-data-redis</artifactId>

	</dependency>

```

*   配置类

```java
	@Configuration

	@EnableCaching

	public class RedisConfig extends CachingConfigurerSupport {

	 

	    @Bean

	    @SuppressWarnings(value = { "unchecked", "rawtypes" })

	    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)

	    {

	        RedisTemplate<Object, Object> template = new RedisTemplate<>();

	        template.setConnectionFactory(connectionFactory);

	 

	        Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class);

	 

	        // 使用StringRedisSerializer来序列化和反序列化redis的key值

	        template.setKeySerializer(new StringRedisSerializer());

	        template.setValueSerializer(serializer);

	 

	        // Hash的key也采用StringRedisSerializer的序列化方式

	        template.setHashKeySerializer(new StringRedisSerializer());

	        template.setHashValueSerializer(serializer);

	 

	        template.afterPropertiesSet();

	        return template;

	    }

	 

	 

	}

```

*   工具类

```java
	@Component

	public class RedisUtil {

	 

	    @Autowired

	    private RedisTemplate redisTemplate;

	 

	    /**

	     * 缓存基本的对象，Integer、String、实体类等

	     *

	     * @param key 缓存的键值

	     * @param value 缓存的值

	     */

	    public <T> void setCacheObject(final String key, final T value)

	    {

	        redisTemplate.opsForValue().set(key, value);

	    }

	 

	    /**

	     * 缓存基本的对象，Integer、String、实体类等

	     *

	     * @param key 缓存的键值

	     * @param value 缓存的值

	     * @param timeout 时间

	     * @param timeUnit 时间颗粒度

	     */

	    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)

	    {

	        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);

	    }

	 

	    /**

	     * 设置有效时间

	     *

	     * @param key Redis键

	     * @param timeout 超时时间

	     * @return true=设置成功；false=设置失败

	     */

	    public boolean expire(final String key, final long timeout)

	    {

	        return expire(key, timeout, TimeUnit.SECONDS);

	    }

	 

	    /**

	     * 设置有效时间

	     *

	     * @param key Redis键

	     * @param timeout 超时时间

	     * @param unit 时间单位

	     * @return true=设置成功；false=设置失败

	     */

	    public boolean expire(final String key, final long timeout, final TimeUnit unit)

	    {

	        return redisTemplate.expire(key, timeout, unit);

	    }

	 

	    /**

	     * 获取有效时间

	     *

	     * @param key Redis键

	     * @return 有效时间

	     */

	    public long getExpire(final String key)

	    {

	        return redisTemplate.getExpire(key);

	    }

	 

	    /**

	     * 判断 key是否存在

	     *

	     * @param key 键

	     * @return true 存在 false不存在

	     */

	    public Boolean hasKey(String key)

	    {

	        return redisTemplate.hasKey(key);

	    }

	 

	    /**

	     * 获得缓存的基本对象。

	     *

	     * @param key 缓存键值

	     * @return 缓存键值对应的数据

	     */

	    public <T> T getCacheObject(final String key)

	    {

	        ValueOperations<String, T> operation = redisTemplate.opsForValue();

	        return operation.get(key);

	    }

	 

	    /**

	     * 删除单个对象

	     *

	     * @param key

	     */

	    public boolean deleteObject(final String key)

	    {

	        return redisTemplate.delete(key);

	    }

	 

	    /**

	     * 删除集合对象

	     *

	     * @param collection 多个对象

	     * @return

	     */

	    public boolean deleteObject(final Collection collection)

	    {

	        return redisTemplate.delete(collection) > 0;

	    }

	 

	    /**

	     * 缓存List数据

	     *

	     * @param key 缓存的键值

	     * @param dataList 待缓存的List数据

	     * @return 缓存的对象

	     */

	    public <T> long setCacheList(final String key, final List<T> dataList)

	    {

	        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);

	        return count == null ? 0 : count;

	    }

	 

	    /**

	     * 获得缓存的list对象

	     *

	     * @param key 缓存的键值

	     * @return 缓存键值对应的数据

	     */

	    public <T> List<T> getCacheList(final String key)

	    {

	        return redisTemplate.opsForList().range(key, 0, -1);

	    }

	 

	    /**

	     * 缓存Set

	     *

	     * @param key 缓存键值

	     * @param dataSet 缓存的数据

	     * @return 缓存数据的对象

	     */

	    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)

	    {

	        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);

	        Iterator<T> it = dataSet.iterator();

	        while (it.hasNext())

	        {

	            setOperation.add(it.next());

	        }

	        return setOperation;

	    }

	 

	    /**

	     * 获得缓存的set

	     *

	     * @param key

	     * @return

	     */

	    public <T> Set<T> getCacheSet(final String key)

	    {

	        return redisTemplate.opsForSet().members(key);

	    }

	 

	    /**

	     * 缓存Map

	     *

	     * @param key

	     * @param dataMap

	     */

	    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)

	    {

	        if (dataMap != null) {

	            redisTemplate.opsForHash().putAll(key, dataMap);

	        }

	    }

	 

	    /**

	     * 获得缓存的Map

	     *

	     * @param key

	     * @return

	     */

	    public <T> Map<String, T> getCacheMap(final String key)

	    {

	        return redisTemplate.opsForHash().entries(key);

	    }

	 

	    /**

	     * 往Hash中存入数据

	     *

	     * @param key Redis键

	     * @param hKey Hash键

	     * @param value 值

	     */

	    public <T> void setCacheMapValue(final String key, final String hKey, final T value)

	    {

	        redisTemplate.opsForHash().put(key, hKey, value);

	    }

	 

	    /**

	     * 获取Hash中的数据

	     *

	     * @param key Redis键

	     * @param hKey Hash键

	     * @return Hash中的对象

	     */

	    public <T> T getCacheMapValue(final String key, final String hKey)

	    {

	        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();

	        return opsForHash.get(key, hKey);

	    }

	 

	    /**

	     * 获取多个Hash中的数据

	     *

	     * @param key Redis键

	     * @param hKeys Hash键集合

	     * @return Hash对象集合

	     */

	    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)

	    {

	        return redisTemplate.opsForHash().multiGet(key, hKeys);

	    }

	 

	    /**

	     * 删除Hash中的某条数据

	     *

	     * @param key Redis键

	     * @param hKey Hash键

	     * @return 是否成功

	     */

	    public boolean deleteCacheMapValue(final String key, final String hKey)

	    {

	        return redisTemplate.opsForHash().delete(key, hKey) > 0;

	    }

	 

	    /**

	     * 获得缓存的基本对象列表

	     *

	     * @param pattern 字符串前缀

	     * @return 对象列表

	     */

	    public Collection<String> keys(final String pattern)

	    {

	        return redisTemplate.keys(pattern);

	    }

	 

	}

```

二、JwtUtil
---------

*   导入依赖

```xml
	<!-- jwt -->

	<dependency>

	     <groupId>io.jsonwebtoken</groupId>

	     <artifactId>jjwt</artifactId>

	     <version>0.9.1</version>

	</dependency>

```

*   配置文件

```yaml
jwt:
header: Authorization
expire: 604800
secret: f4402f4b1c984955a4a22c7c43614ba3
```

*   工具类

```java
@Data

@Component

@ConfigurationProperties(prefix = "jwt")

public class JwtUtil {



    private String header;

    private String secret;

    private long expire;



    /**

	     * 生成token

	     * @param str

	     * @return

	     */

    public String generateToken(String str){

        Date now = new Date();

        //失效时间

        Date expireDate = new Date(now.getTime() + 1000 * expire);

        return Jwts.builder()

            .setHeaderParam("typ","jwt")

            .setSubject(str)

            .setIssuedAt(now)

            .setExpiration(expireDate)

            .signWith(SignatureAlgorithm.HS512,secret)

            .compact();

    }



    /**
	     * 解析token
	     * @param jwt
	     * @return
	     */
    public Claims getClaimsByToken(String jwt){

        try {
            return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(jwt)
                .getBody();
        }catch (Exception e){
            return null;
        }
    }


    /**

	     * 判断jwt是否过期

	     * @param claims

	     * @return

	     */

    public boolean jwtExpire(Claims claims){

        return claims.getExpiration().before(new Date());

    }



}

```

三、Result
--------

*   统一返回结果类

```java
	@Data

	public class Result implements Serializable {

	 

	    private int code;

	    private String msg;

	    private Object data;

	 

	    public static Result success(Object data) {

	        return success(200, "操作成功", data);

	    }

	 

	    public static Result fail(String msg) {

	        return fail(400, msg, null);

	    }

	 

	    public static Result success (int code, String msg, Object data) {

	        Result result = new Result();

	        result.setCode(code);

	        result.setMsg(msg);

	        result.setData(data);

	        return result;

	    }

	 

	    public static Result fail (int code, String msg, Object data) {

	        Result result = new Result();

	        result.setCode(code);

	        result.setMsg(msg);

	        result.setData(data);

	        return result;

	    }

	 

	}

```

```java
@Data
public class Result<T> {

    // 状态码
    private Integer code;
    // 信息
    private String message;
    // 数据
    private T data;

    // 构造私有化
    private Result() { }

    // 设置数据,返回对象的方法
    public static<T> Result<T> build(T data,Integer code,String message) {
        // 创建Resullt对象，设置值，返回对象
        Result<T> result = new Result<>();
        // 判断返回结果中是否需要数据
        if(data != null) {
            // 设置数据到result对象
            result.setData(data);
        }
        // 设置其他值
        result.setCode(code);
        result.setMessage(message);
        // 返回设置值之后的对象
        return result;
    }

    // 设置数据,返回对象的方法
    public static<T> Result<T> build(T data,ResultCodeEnum resultCodeEnum) {
        // 创建Resullt对象，设置值，返回对象
        Result<T> result = new Result<>();
        // 判断返回结果中是否需要数据
        if(data != null) {
            // 设置数据到result对象
            result.setData(data);
        }
        //设置其他值
        result.setCode(resultCodeEnum.getCode());
        result.setMessage(resultCodeEnum.getMessage());
        //返回设置值之后的对象
        return result;
    }

    // 成功的方法
    public static<T> Result<T> ok(T data) {
        Result<T> result = build(data, ResultCodeEnum.SUCCESS);
        return result;
    }

    // 失败的方法
    public static<T> Result<T> fail(T data) {
        return build(data,ResultCodeEnum.FAIL);
    }

}
```

```java
@Getter
public enum ResultCodeEnum {

    SUCCESS(200,"成功"),
    FAIL(201, "失败"),

    SERVICE_ERROR(2012, "服务异常"),
    DATA_ERROR(204, "数据异常"),
    ILLEGAL_REQUEST(205, "非法请求"),
    REPEAT_SUBMIT(206, "重复提交"),

    LOGIN_AUTH(208, "未登陆"),
    PERMISSION(209, "没有权限"),
    ...
    ;

    private Integer code;

    private String message;

    private ResultCodeEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```



四、HttpUtils
-----------

```java
	public class HttpUtils {

	    private static final Logger log = LoggerFactory.getLogger(HttpUtils.class);

	 

	 

	    /**

	     * 向指定 URL 发送GET方法的请求

	     *

	     * @param url 发送请求的 URL

	     * @return 所代表远程资源的响应结果

	     */

	    public static String sendGet(String url) {

	        return sendGet(url, StringUtils.EMPTY);

	    }

	 

	    /**

	     * 向指定 URL 发送GET方法的请求

	     *

	     * @param url   发送请求的 URL

	     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。

	     * @return 所代表远程资源的响应结果

	     */

	    public static String sendGet(String url, String param) {

	        return sendGet(url, param, "utf-8");

	    }

	 

	    /**

	     * 向指定 URL 发送GET方法的请求

	     *

	     * @param url         发送请求的 URL

	     * @param param       请求参数，请求参数应该是 name1=value1&name2=value2 的形式。

	     * @param contentType 编码类型

	     * @return 所代表远程资源的响应结果

	     */

	    public static String sendGet(String url, String param, String contentType) {

	        StringBuilder result = new StringBuilder();

	        BufferedReader in = null;

	        try {

	            String urlNameString = StringUtils.isNotBlank(param) ? url + "?" + param : url;

	            log.info("sendGet - {}", urlNameString);

	            URL realUrl = new URL(urlNameString);

	            URLConnection connection = realUrl.openConnection();

	            connection.setRequestProperty("accept", "*/*");

	            connection.setRequestProperty("connection", "Keep-Alive");

	            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");

	            connection.connect();

	            in = new BufferedReader(new InputStreamReader(connection.getInputStream(), contentType));

	            String line;

	            while ((line = in.readLine()) != null) {

	                result.append(line);

	            }

	            log.info("recv - {}", result);

	        } catch (ConnectException e) {

	            log.error("调用HttpUtils.sendGet ConnectException, url=" + url + ",param=" + param, e);

	        } catch (SocketTimeoutException e) {

	            log.error("调用HttpUtils.sendGet SocketTimeoutException, url=" + url + ",param=" + param, e);

	        } catch (IOException e) {

	            log.error("调用HttpUtils.sendGet IOException, url=" + url + ",param=" + param, e);

	        } catch (Exception e) {

	            log.error("调用HttpsUtil.sendGet Exception, url=" + url + ",param=" + param, e);

	        } finally {

	            try {

	                if (in != null) {

	                    in.close();

	                }

	            } catch (Exception ex) {

	                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);

	            }

	        }

	        return result.toString();

	    }

	 

	    /**

	     * 向指定 URL 发送POST方法的请求

	     *

	     * @param url   发送请求的 URL

	     * @param param 请求参数，请求参数应该是 name1=value1&name2=value2 的形式。

	     * @return 所代表远程资源的响应结果

	     */

	    public static String sendPost(String url, String param) {

	        PrintWriter out = null;

	        BufferedReader in = null;

	        StringBuilder result = new StringBuilder();

	        try {

	            String urlNameString = url;

	            log.info("sendPost - {}", urlNameString);

	            URL realUrl = new URL(urlNameString);

	            URLConnection conn = realUrl.openConnection();

	            conn.setRequestProperty("accept", "*/*");

	            conn.setRequestProperty("connection", "Keep-Alive");

	            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");

	            conn.setRequestProperty("Accept-Charset", "utf-8");

	            conn.setRequestProperty("contentType", "utf-8");

	            conn.setDoOutput(true);

	            conn.setDoInput(true);

	            out = new PrintWriter(conn.getOutputStream());

	            out.print(param);

	            out.flush();

	            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "utf-8"));

	            String line;

	            while ((line = in.readLine()) != null) {

	                result.append(line);

	            }

	            log.info("recv - {}", result);

	        } catch (ConnectException e) {

	            log.error("调用HttpUtils.sendPost ConnectException, url=" + url + ",param=" + param, e);

	        } catch (SocketTimeoutException e) {

	            log.error("调用HttpUtils.sendPost SocketTimeoutException, url=" + url + ",param=" + param, e);

	        } catch (IOException e) {

	            log.error("调用HttpUtils.sendPost IOException, url=" + url + ",param=" + param, e);

	        } catch (Exception e) {

	            log.error("调用HttpsUtil.sendPost Exception, url=" + url + ",param=" + param, e);

	        } finally {

	            try {

	                if (out != null) {

	                    out.close();

	                }

	                if (in != null) {

	                    in.close();

	                }

	            } catch (IOException ex) {

	                log.error("调用in.close Exception, url=" + url + ",param=" + param, ex);

	            }

	        }

	        return result.toString();

	    }

	 

	    public static String sendSSLPost(String url, String param) {

	        StringBuilder result = new StringBuilder();

	        String urlNameString = url + "?" + param;

	        try {

	            log.info("sendSSLPost - {}", urlNameString);

	            SSLContext sc = SSLContext.getInstance("SSL");

	            sc.init(null, new TrustManager[]{new TrustAnyTrustManager()}, new java.security.SecureRandom());

	            URL console = new URL(urlNameString);

	            HttpsURLConnection conn = (HttpsURLConnection) console.openConnection();

	            conn.setRequestProperty("accept", "*/*");

	            conn.setRequestProperty("connection", "Keep-Alive");

	            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");

	            conn.setRequestProperty("Accept-Charset", "utf-8");

	            conn.setRequestProperty("contentType", "utf-8");

	            conn.setDoOutput(true);

	            conn.setDoInput(true);

	 

	            conn.setSSLSocketFactory(sc.getSocketFactory());

	            conn.setHostnameVerifier(new TrustAnyHostnameVerifier());

	            conn.connect();

	            InputStream is = conn.getInputStream();

	            BufferedReader br = new BufferedReader(new InputStreamReader(is));

	            String ret = "";

	            while ((ret = br.readLine()) != null) {

	                if (ret != null && !ret.trim().equals("")) {

	                    result.append(new String(ret.getBytes("ISO-8859-1"), "utf-8"));

	                }

	            }

	            log.info("recv - {}", result);

	            conn.disconnect();

	            br.close();

	        } catch (ConnectException e) {

	            log.error("调用HttpUtils.sendSSLPost ConnectException, url=" + url + ",param=" + param, e);

	        } catch (SocketTimeoutException e) {

	            log.error("调用HttpUtils.sendSSLPost SocketTimeoutException, url=" + url + ",param=" + param, e);

	        } catch (IOException e) {

	            log.error("调用HttpUtils.sendSSLPost IOException, url=" + url + ",param=" + param, e);

	        } catch (Exception e) {

	            log.error("调用HttpsUtil.sendSSLPost Exception, url=" + url + ",param=" + param, e);

	        }

	        return result.toString();

	    }

	 

	    private static class TrustAnyTrustManager implements X509TrustManager {

	        @Override

	        public void checkClientTrusted(X509Certificate[] chain, String authType) {

	        }

	 

	        @Override

	        public void checkServerTrusted(X509Certificate[] chain, String authType) {

	        }

	 

	        @Override

	        public X509Certificate[] getAcceptedIssuers() {

	            return new X509Certificate[]{};

	        }

	    }

	 

	    private static class TrustAnyHostnameVerifier implements HostnameVerifier {

	        @Override

	        public boolean verify(String hostname, SSLSession session) {

	            return true;

	        }

	    }

	}

```

### ID类

```java
package top.lazyboy;

import java.util.Random;
import java.util.UUID;

/**
 * 各种id生成策略
 * @version 1.0
 */
public class IDUtils {

	/**
	 * 图片名生成
	 */
	public static String genImageName() {
		// 取当前时间的长整形值包含毫秒
		long millis = System.currentTimeMillis();
		// long millis = System.nanoTime();
		// 加上三位随机数
		Random random = new Random();
		// 返回0~999的数据.
		int end3 = random.nextInt(999);
		// 如果不足三位前面补0. %d - 模拟C语言中的数学占位符.  03代表必须三位数字,不足三位使用0补齐.
		String str = millis + String.format("%03d", end3);
		return str;
	}
	
	/**
	 * 商品id生成
	 */
	public static long genItemId() {
		//取当前时间的长整形值包含毫秒
		long millis = System.currentTimeMillis();
		//long millis = System.nanoTime();
		//加上两位随机数
		Random random = new Random();
		int end2 = random.nextInt(99);
		//如果不足两位前面补0
		String str = millis + String.format("%02d", end2);
		long id = new Long(str);
		return id;
	}
	
	public static void main(String[] args) {
		for(int i=0;i< 100;i++)
		System.out.println(genItemId());
	}
}
```

### MD5

```java

```

### MybatisPlus配置类

```java
@Configuration
@MapperScan("com.xxx.*.mapper")
@EnableTransactionManagement
public class MybatisPlusConfig {

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,
     * 需要设置 MybatisConfiguration#useDeprecatedExecutor = false
     * 避免缓存出现问题(该属性会在旧插件移除后一同移除)
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> configuration.setUseDeprecatedExecutor(false);
    }
}
```

### Redis配置类

```java
@Configuration
@EnableCaching
public class RedisConfig {

    // 使用默认标签做缓存
    @Bean
    public KeyGenerator wiselyKeyGenerator() {
        return new KeyGenerator() {
            @Override
            public Object generate(Object target, Method method, Object... params) {
                StringBuilder sb = new StringBuilder();
                sb.append(target.getClass().getName());
                sb.append(method.getName());
                for (Object obj : params) {
                    sb.append(obj.toString());
                }
                return sb.toString();
            }
        };
    }

    // 声明模板
    /*
    ref = 表示引用
    value = 具体的值
    <bean class="org.springframework.data.redis.core.RedisTemplate" >
        <property name="defaultSerializer" ref = "">
    </bean>
     */
    //  工具类：
    @Bean
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        //  将Redis 中 string ，hash 数据类型，自动序列化！
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);

        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        //解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofDays(365))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();

        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}
```

## 类库

# 常用开发库 - Apache Common包

> Apache common不仅被成千上万开源工具使用，更是学习Java编程比较好的代码参考工具，效率工具。@pdai

[Apache Common包简介]()[Common包包含哪些]()[常用包梳理]()[Commons BeanUtils]()[Commons Codec]()[Commons Collections]()[Commons Compress]()[Commons Configuration]()[Commons CSV]()[Commons Daemon]()[Commons DBCP]()[Commons DBUtils]()[Commons Digester]()[Commons Email]()[Commons Exec]()[Commons FileUpload]()[Commons IO]()[Commons JCI]()[Commons Lang3]()[Commons Logging]()[Commons Math]()[Commons Net]()[Commons Pool]()[Commons Primitives]()[Commons Validator]()[Apache HttpClient]()[Common 包检索和使用]()[参考文章]()

## [#](#apache-common包简介) Apache Common包简介

Apache Commons是对JDK的拓展，包含了很多开源的工具，用于解决平时编程经常会遇到的问题，减少重复劳动。官网网址:http://commons.apache.org

## [#](#common包包含哪些) Common包包含哪些

- 请参考：[Apache Common官方网站在新窗口打开](http://commons.apache.org/)

我从官网上截了个图，主要功能如下, 其中我划线的是常用的：

![img](./F:/images/develop/package/dev-package-common-1.png)

![img](./F:/images/develop/package/dev-package-common-2.png)

## [#](#常用包梳理) 常用包梳理

### [#](#commons-beanutils) Commons BeanUtils

针对Bean的一个工具集。由于Bean往往是有一堆get和set组成，所以BeanUtils也是在此基础上进行一些包装。它利用Java的反射机制，从动态的生成对bean的getter和setter的调用代码，到模拟创建一个动态的bean，等等。这个包看似简单，却是很多开源项目的基石：如在著名的Struts和Spring Framework中，我们都能找到BeanUtils的影子。大家猜猜看，有哪位名人是BeanUtils的作者之一？没错，就是Struts的创始人Craig McClanahan。

一个比较常用的功能是Bean Copy，也就是copy bean的属性。如果做分层架构开发的话就会用到，比如从PO（Persistent Object）拷贝数据到VO（Value Object）。

Commons BeanUtils一共包括如下5个包：

```java
org.apache.commons.beanutils – 核心包，定义一组Utils类和需要用到的接口规范

org.apache.commons.beanutils.converters – 转换String到需要类型的类，实现Converter接口

org.apache.commons.beanutils.locale –beanutils的locale敏感版本

org.apache.commons.beanutils.locale.converters– converters的locale敏感版本

org.apache.commons.collections – beanutils使用到的Collection类
```

### [#](#commons-codec) Commons Codec

是编码和解码组件，提供常用的编码和解码方法，如DES、SHA1、MD5、Base64、URL和Soundx等。

### [#](#commons-collections) Commons Collections

是一个集合组件，扩展了Java标准Collections API，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。

我们先来浏览一下它的包结构。一共是12个：

```java
org.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类

org.apache.commons.collections.bag – 实现Bag接口的一组类

org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类

org.apache.commons.collections.buffer – 实现Buffer接口的一组类

org.apache.commons.collections.collection –实现java.util.Collection接口的一组类

org.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类

org.apache.commons.collections.functors –Commons Collections自定义的一组功能类

org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类

org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类

org.apache.commons.collections.list – 实现java.util.List接口的一组类

org.apache.commons.collections.map – 实现Map系列接口的一组类

org.apache.commons.collections.set – 实现Set系列接口的一组类
```

- 作为容器类的补充，我们可以找到Bag、Buffer、BidiMap、OrderedMap等等；
- 作为操作类的补充，我们可以找到CollectionUtils、IteratorUtils、ListUtils、SetUtils等等；
- 作为辅助类的补充，我们可以找到MapIterator、Closure、Predicate、Transformer等等；

### [#](#commons-compress) Commons Compress

是一个压缩、解压缩文件的组件，可以操作rar、cpio、Unix dump、tar、zip、gzip、XZ、Pack200和bzip2格式的压缩文件。

### [#](#commons-configuration) Commons Configuration

是一个Java应用程序的配置管理工具，可以从properties或者xml文件中加载配置信息。

### [#](#commons-csv) Commons CSV

是一个用来读写各种Comma Separated Value(CSV)格式文件的Java类库。

### [#](#commons-daemon) Commons Daemon

实现将普通的Java应用变成系统的后台服务,例如 Tomcat 就是利用这个项目来实现作为 Linux 和 Windows 的服务启动和停止的。

### [#](#commons-dbcp) Commons DBCP

数据库连接池。

### [#](#commons-dbutils) Commons DBUtils

是JDBC工具组件，对传统操作数据库的类进行二次封装，可以把结果集转化成List。

### [#](#commons-digester) Commons Digester

是XML到Java对象的映射工具集。

### [#](#commons-email) Commons Email

是邮件操作组件，对Java Mail API进行了封装，提供了常用的邮件发送和接收类，简化邮件操作。该组件依赖Java Mail API。

### [#](#commons-exec) Commons Exec

提供一些常用的方法用来执行外部进程，如执行exe文件或命令行。

### [#](#commons-fileupload) Commons FileUpload

为Web应用程序或Servlet提供文件上传功能，Struts2和SpringMVC的文件上传组件。

### [#](#commons-io) Commons IO

是处理IO的工具类包，对java.io进行扩展，提供了更加方便的IO操作。

### [#](#commons-jci) Commons JCI

提供通用的Java编译器接口。

### [#](#commons-lang3) Commons Lang3

是处理Java基本对象方法的工具类包，该类包提供对字符、数组等基本对象的操作，弥补了java.lang api基本处理方法上的不足。

- [API 文档在新窗口打开](http://commons.apache.org/proper/commons-lang/javadocs/api-release/index.html)

```java
ArrayUtils – 用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；

BitField – 用于操作位元，提供了一些方便而安全的方法；

BooleanUtils – 用于操作和转换boolean或者Boolean及相应的数组；

CharEncoding – 包含了Java环境支持的字符编码，提供是否支持某种编码的判断；

CharRange – 用于设定字符范围并做相应检查；

CharSet – 用于设定一组字符作为范围并做相应检查；

CharSetUtils – 用于操作CharSet；

CharUtils – 用于操作char值和Character对象；

ClassUtils – 用于对Java类的操作，不使用反射；

ObjectUtils – 用于操作Java对象，提供null安全的访问和其他一些功能；

RandomStringUtils – 用于生成随机的字符串；

SerializationUtils – 用于处理对象序列化，提供比一般Java序列化更高级的处理能力；

StringEscapeUtils – 用于正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码；

StringUtils – 处理String的核心类，提供了相当多的功能；

SystemUtils – 在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断；

Validate – 提供验证的操作，有点类似assert断言；

WordUtils – 用于处理单词大小写、换行等。
```

### [#](#commons-logging) Commons Logging

提供统一的日志接口，同时兼顾轻量级和不依赖于具体的实现。类包给中间件/日志工具开发者一个简单的日志操作抽象，允许程序开发人员使用不同的具体日志实现工具。

### [#](#commons-math) Commons Math

轻量级自容器的数学和统计计算方法类包，包含大多数常用的数值算法。

### [#](#commons-net) Commons Net

封装了各种网络协议的客户端，支持FTP、NNTP、SMTP、POP3、Telnet等协议。

### [#](#commons-pool) Commons Pool

提供了一整套用于实现对象池化的框架，以及若干各具特色的对象池实现，可以有效地减少处理对象池化时的工作量。类包用于提高像文件句柄、数据库连接、socket通信这类大对象的调用效率，简单的说就是一种对象一次创建多次使用的技术。

### [#](#commons-primitives) Commons Primitives

提供了一个更小，更快和更易使用的对Java基本类型的支持。

### [#](#commons-validator) Commons Validator

提供了一个简单的、可扩展的框架来在一个XML文件中定义校验器(校验方法)和校验规则。支持校验规则的和错误消息的国际化。

### [#](#apache-httpclient) Apache HttpClient

曾经是Apache Commons的子项目，后来独立出来。HttpClient简化HTTP客户端与服务器的各种通讯，实现HTTP客户端程序（也就是浏览器程序）的功能。



# 常用开发库 - Google Guava包

> Google出品的common包，我比较常用的比如Guava缓存等。@pdai

[Google Guava简介]()[推荐网址]()[使用Guava]()[内容简介]()[基本工具 [Basic utilities\]]()[集合[Collections\]]()[缓存[Caches\]]()[函数式风格[Functional idioms\]]()[并发[Concurrency\]]()[字符串处理[Strings\]]()[原生类型[Primitives\]]()[区间[Ranges\]]()[I/O]()[散列[Hash\]]()[事件总线[EventBus\]]()[数学运算[Math\]]()[反射[Reflection\]]()[参考文章]()

## [#](#google-guava简介) Google Guava简介

Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。

guava的优点：

- 高效设计良好的API，被Google的开发者设计，实现和使用
- 遵循高效的java语法实践
- 使代码更刻度，简洁，简单
- 节约时间，资源，提高生产力

## [#](#推荐网址) 推荐网址

- [Guava Wiki在新窗口打开](https://github.com/google/guava/wiki/Home)
- [Guava API Doc在新窗口打开](https://guava.dev/releases/snapshot-jre/api/docs/)
- [Guava Github在新窗口打开](https://github.com/google/guava)
- [Guava 中文教程 - ifeve.com在新窗口打开](http://ifeve.com/google-guava/) 看这里

## [#](#使用guava) 使用Guava

注意：JDK 1.8 or higher.

```xml
<dependency>
  <groupId>com.google.guava</groupId>
  <artifactId>guava</artifactId>
  <version>28.2-jre</version>
  <!-- or, for Android: -->
  <version>28.2-android</version>
</dependency>
```

## [#](#内容简介) 内容简介

### [#](#基本工具-basic-utilities) 基本工具 [Basic utilities]

让使用Java语言变得更舒适

1.1 [使用和避免null在新窗口打开](http://ifeve.com/google-guava-using-and-avoiding-null/)：null是模棱两可的，会引起令人困惑的错误，有些时候它让人很不舒服。很多Guava工具类用快速失败拒绝null值，而不是盲目地接受

1.2 [前置条件在新窗口打开](http://ifeve.com/google-guava-preconditions/): 让方法中的条件检查更简单

1.3 [常见Object方法在新窗口打开](http://ifeve.com/google-guava-commonobjectutilities/): 简化Object方法实现，如hashCode()和toString()

1.4 [排序在新窗口打开](http://ifeve.com/google-guava-ordering/): Guava强大的”流畅风格比较器”

1.5 [Throwables在新窗口打开](http://ifeve.com/google-guava-throwables/)：简化了异常和错误的传播与检查

### [#](#集合-collections) 集合[Collections]

Guava对JDK集合的扩展，这是Guava最成熟和为人所知的部分

2.1 [不可变集合在新窗口打开](http://ifeve.com/google-guava-immutablecollections/): 用不变的集合进行防御性编程和性能提升。

2.2 [新集合类型在新窗口打开](http://ifeve.com/google-guava-newcollectiontypes/): multisets, multimaps, tables, bidirectional maps等

2.3 [强大的集合工具类在新窗口打开](http://ifeve.com/google-guava-collectionutilities/): 提供java.util.Collections中没有的集合工具

2.4 [扩展工具类](http://ifeve.com/google-guava-collectionhelpersexplained/：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器

### [#](#缓存-caches) 缓存[Caches]

[Guava Cache在新窗口打开](http://ifeve.com/google-guava-cachesexplained/)：本地缓存实现，支持多种缓存过期策略

### [#](#函数式风格-functional-idioms) 函数式风格[Functional idioms]

[Guava的函数式支持在新窗口打开](http://ifeve.com/google-guava-functional/)可以显著简化代码，但请谨慎使用它

### [#](#并发-concurrency) 并发[Concurrency]

强大而简单的抽象，让编写正确的并发代码更简单

5.1 [ListenableFuture在新窗口打开](http://ifeve.com/google-guava-listenablefuture/)：完成后触发回调的Future

5.2 [Service框架在新窗口打开](http://ifeve.com/google-guava-serviceexplained/)：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑

### [#](#字符串处理-strings) 字符串处理[Strings]

[字符串处理在新窗口打开](http://ifeve.com/google-guava-strings/): 非常有用的字符串工具，包括分割、连接、填充等操作

### [#](#原生类型-primitives) 原生类型[Primitives]

[原生类型在新窗口打开](http://ifeve.com/google-guava-primitives/): 扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式

### [#](#区间-ranges) 区间[Ranges]

[区间在新窗口打开](http://ifeve.com/google-guava-ranges/): 可比较类型的区间API，包括连续和离散类型

### [#](#i-o) I/O

[I/O在新窗口打开](http://ifeve.com/google-guava-io/): 简化I/O尤其是I/O流和文件的操作，针对Java5和6版本

### [#](#散列-hash) 散列[Hash]

[散列在新窗口打开](http://ifeve.com/google-guava-hashing/): 提供比Object.hashCode()更复杂的散列实现，并提供布鲁姆过滤器的实现

### [#](#事件总线-eventbus) 事件总线[EventBus]

[事件总线在新窗口打开](http://ifeve.com/google-guava-eventbus/):发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中

### [#](#数学运算-math) 数学运算[Math]

[数学运算在新窗口打开](http://ifeve.com/google-guava-math/):优化的、充分测试的数学工具类

### [#](#反射-reflection) 反射[Reflection]

[反射在新窗口打开](http://ifeve.com/guava-reflection/): Guava 的 Java 反射机制工具类

# 常用开发库 - Hutool包

> Hutool作为后起之秀，功能上也比较全。但是要注意一点，它的开源协议是：中国第一个开源协议[木兰宽松许可证, 第1版在新窗口打开](http://license.coscl.org.cn/MulanPSL)，对此在商业项目中需要谨慎些，在个人项目无所谓。@pdai

[简介]()[Hutool名称的由来]()[Hutool如何改变我们的coding方式]()[包含组件]()[文档]()[安装]()[Maven]()[Gradle]()[非Maven项目]()[编译安装]()

## [#](#简介) 简介

Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。

Hutool中的工具方法来自于每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；

Hutool是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。

### [#](#hutool名称的由来) Hutool名称的由来

Hutool = Hu + tool，是原公司项目底层代码剥离后的开源库，“Hu”是公司名称的表示，tool表示工具。Hutool谐音“糊涂”，一方面简洁易懂，一方面寓意“难得糊涂”。

### [#](#hutool如何改变我们的coding方式) Hutool如何改变我们的coding方式

Hutool的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。

以计算MD5为例：

- 【以前】打开搜索引擎 -> 搜“Java MD5加密” -> 打开某篇博客-> 复制粘贴 -> 改改好用
- 【现在】引入Hutool -> SecureUtil.md5()

Hutool的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。

## [#](#包含组件) 包含组件

一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：

| 模块               | 介绍                                                         |
| ------------------ | ------------------------------------------------------------ |
| hutool-aop         | JDK动态代理封装，提供非IOC下的切面支持                       |
| hutool-bloomFilter | 布隆过滤，提供一些Hash算法的布隆过滤                         |
| hutool-cache       | 简单缓存实现                                                 |
| hutool-core        | 核心，包括Bean操作、日期、各种Util等                         |
| hutool-cron        | 定时任务模块，提供类Crontab表达式的定时任务                  |
| hutool-crypto      | 加密解密模块，提供对称、非对称和摘要算法封装                 |
| hutool-db          | JDBC封装后的数据操作，基于ActiveRecord思想                   |
| hutool-dfa         | 基于DFA模型的多关键字查找                                    |
| hutool-extra       | 扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等） |
| hutool-http        | 基于HttpUrlConnection的Http客户端封装                        |
| hutool-log         | 自动识别日志实现的日志门面                                   |
| hutool-script      | 脚本执行封装，例如Javascript                                 |
| hutool-setting     | 功能更强大的Setting配置文件和Properties封装                  |
| hutool-system      | 系统参数调用封装（JVM信息等）                                |
| hutool-json        | JSON实现                                                     |
| hutool-captcha     | 图片验证码实现                                               |
| hutool-poi         | 针对POI中Excel的封装                                         |
| hutool-socket      | 基于Java的NIO和AIO的Socket封装                               |

可以根据需求对每个模块单独引入，也可以通过引入`hutool-all`方式引入所有模块。

## [#](#文档) 文档

- [中文文档在新窗口打开](https://www.hutool.cn/docs/) 看这里
- [中文文档（备用）在新窗口打开](https://www.hutool.club/docs/)
- [参考API在新窗口打开](https://apidoc.gitee.com/loolly/hutool/)

## [#](#安装) 安装

### [#](#maven) Maven

在项目的pom.xml的dependencies中加入以下内容:

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.1.0</version>
</dependency>
```

### [#](#gradle) Gradle

```text
compile 'cn.hutool:hutool-all:5.1.0'
```

### [#](#非maven项目) 非Maven项目

点击以下任一链接，下载`hutool-all-X.X.X.jar`即可：

- [Maven中央库1在新窗口打开](https://repo1.maven.org/maven2/cn/hutool/hutool-all/5.1.0/)
- [Maven中央库2在新窗口打开](http://repo2.maven.org/maven2/cn/hutool/hutool-all/5.1.0/)

> 注意 Hutool 5.x支持JDK8+，对Android平台没有测试，不能保证所有工具类获工具方法可用。 如果你的项目使用JDK7，请使用Hutool 4.x版本

# 常用开发库 - Lombok工具库详解

> Lombok是一款非常实用Java工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。实际上我并不推荐使用Lombok（不主动使用它）, 但是因为它有着很大的使用量，我们仍然有必要掌握它，不仅知道如何使用和它解决的问题，还要知道它的坑。@pdai

[Lombok的引入]()[在引入Lombok之前我们是怎么做的]()[Lombok的安装和使用]()[Lombok官网]()[Lombok安装]()[Lombok注解说明]()[Lombok代码示例]()[Lombok深入理解]()[Lombok解决了什么问题]()[Lombok的原理]()[Lombok类似原理工具有什么]()[Lombok没有未来 - Java14 Record了解下]()[Lombok有什么坑]()[@Data的坑]()[代码可读性，可调试性低]()[Lombok有很强的侵入性]()[Lombok破坏了封装性]()[总结]()[参考文章]()

## [#](#lombok的引入) Lombok的引入

我们通常需要编写大量代码才能使类变得有用。如以下内容：

- `toString()`方法
- `hashCode()` and `equals()`方法
- `Getter` and `Setter` 方法
- 构造函数

对于这种简单的类，这些方法通常是无聊的、重复的，而且是可以很容易地机械地生成的那种东西(ide通常提供这种功能)。

### [#](#在引入lombok之前我们是怎么做的) 在引入Lombok之前我们是怎么做的

IDE中添加`getter/setter`, `toString`等代码

![img](./F:/images/develop/package/dev-package-lombok-5.png)

## [#](#lombok的安装和使用) Lombok的安装和使用

> 下面总结下如何使用。

### [#](#lombok官网) Lombok官网

- [Lombok官网在新窗口打开](https://projectlombok.org/)

### [#](#lombok安装) Lombok安装

IDEA搜索Lombok插件

![img](./F:/images/develop/package/dev-package-lombok-4.png)

另外需要注意的是，在使用lombok注解的时候记得要导入lombok.jar包到工程，如果使用的是Maven的工程项目的话，要在其pom.xml中添加依赖如下

```xml
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.12</version>
    <scope>provided</scope>
</dependency>
```

### [#](#lombok注解说明) Lombok注解说明

看[官网这里在新窗口打开](https://projectlombok.org/features/all)

- `val`：用在局部变量前面，相当于将变量声明为final
- `@NonNull`：给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出`NPE`（NullPointerException）
- `@Cleanup`：自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成`try-finally`这样的代码来关闭流
- `@Getter/@Setter`：用在属性上，再也不用自己手写`setter`和`getter`方法了，还可以指定访问范围
- `@ToString`：用在类上，可以自动覆写`toString`方法，当然还可以加其他参数，例如`@ToString(exclude=”id”)`排除id属性，或者`@ToString(callSuper=true, includeFieldNames=true)`调用父类的`toString`方法，包含所有属性
- `@EqualsAndHashCode`：用在类上，自动生成`equals`方法和`hashCode`方法
- `@NoArgsConstructor`, `@RequiredArgsConstructor` and `@AllArgsConstructor`：用在类上，自动生成无参构造和使用所有参数的构造函数以及把所有+ `@NonNull属性作为参数的构造函数，如果指定`staticName = “of”`参数，同时还会生成一个返回类对象的静态工厂方法，比使用构造函数方便很多
- `@Data`：注解在类上，相当于同时使用了`@ToString`、`@EqualsAndHashCode`、`@Getter`、`@Setter`和`@RequiredArgsConstrutor`这些注解，对于POJO类十分有用
- `@Value`：用在类上，是`@Data`的不可变形式，相当于为属性添加final声明，只提供getter方法，而不提供setter方法
- `@Builder`：用在类、构造器、方法上，为你提供复杂的builder APIs，让你可以像如下方式一样调用`Person.builder().name("Adam Savage").city("San Francisco").job("Mythbusters").job("Unchained Reaction").build()`;更多说明参考Builder
- `@SneakyThrows`：自动抛受检异常，而无需显式在方法上使用throws语句
- `@Synchronized`：用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性`$lock`或`$LOCK`，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误
- `@Getter(lazy=true)`：可以替代经典的Double Check Lock样板代码
- `@Log`：根据不同的注解生成不同类型的log对象，但是实例名称都是log，有六种可选实现类
- `@CommonsLog` Creates log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);
- `@Log` Creates log = java.util.logging.Logger.getLogger(LogExample.class.getName());
- `@Log4j` Creates log = org.apache.log4j.Logger.getLogger(LogExample.class);
- `@Log4j2` Creates log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);
- `@Slf4j` Creates log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
- `@XSlf4j` Creates log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);

### [#](#lombok代码示例) Lombok代码示例

- val示例

```java
public static void main(String[] args) {
    val sets = new HashSet<String>();
    val lists = new ArrayList<String>();
    val maps = new HashMap<String, String>();
    //=>相当于如下
    final Set<String> sets2 = new HashSet<>();
    final List<String> lists2 = new ArrayList<>();
    final Map<String, String> maps2 = new HashMap<>();
}
```

- `@NonNull`示例

```java
public void notNullExample(@NonNull String string) {
    string.length();
}
//=>相当于
public void notNullExample(String string) {
    if (string != null) {
        string.length();
    } else {
        throw new NullPointerException("null");
    }
}
```

- `@Cleanup`示例

```java
public static void main(String[] args) {
    try {
        @Cleanup InputStream inputStream = new FileInputStream(args[0]);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    //=>相当于
    InputStream inputStream = null;
    try {
        inputStream = new FileInputStream(args[0]);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

- `@Getter/@Setter`示例

```java
@Setter(AccessLevel.PUBLIC)
@Getter(AccessLevel.PROTECTED)
private int id;
private String shape;
```

- `@ToString`示例

```java
@ToString(exclude = "id", callSuper = true, includeFieldNames = true)
public class LombokDemo {
    private int id;
    private String name;
    private int age;
    public static void main(String[] args) {
        //输出LombokDemo(super=LombokDemo@48524010, name=null, age=0)
        System.out.println(new LombokDemo());
    }
}
```

- `@EqualsAndHashCode`示例

```java
@EqualsAndHashCode(exclude = {"id", "shape"}, callSuper = false)
public class LombokDemo {
    private int id;
    private String shape;
}
```

- `@NoArgsConstructor`, `@RequiredArgsConstructor` and `@AllArgsConstructor`示例

```java
@NoArgsConstructor
@RequiredArgsConstructor(staticName = "of")
@AllArgsConstructor
public class LombokDemo {
    @NonNull
    private int id;
    @NonNull
    private String shape;
    private int age;
    public static void main(String[] args) {
        new LombokDemo(1, "circle");
        //使用静态工厂方法
        LombokDemo.of(2, "circle");
        //无参构造
        new LombokDemo();
        //包含所有参数
        new LombokDemo(1, "circle", 2);
    }
}
```

- `@Data`示例

```java
import lombok.Data;
@Data
public class Menu {
    private String shopId;
    private String skuMenuId;
    private String skuName;
    private String normalizeSkuName;
    private String dishMenuId;
    private String dishName;
    private String dishNum;
    //默认阈值
    private float thresHold = 0;
    //新阈值
    private float newThresHold = 0;
    //总得分
    private float totalScore = 0;
}
```

- `@Value`示例

```java
@Value
public class LombokDemo {
    @NonNull
    private int id;
    @NonNull
    private String shap;
    private int age;
    //相当于
    private final int id;
    public int getId() {
        return this.id;
    }
    ...
}
```

- `@Builder`示例

```java
@Builder
public class BuilderExample {
    private String name;
    private int age;
    @Singular
    private Set<String> occupations;
    public static void main(String[] args) {
        LombokDemo3 test = LombokDemo3.builder().age(11).name("test")
                .occupation("1")
                .occupation("2")
                .build();
    }
}
```

@Singular可以为集合类型的参数或字段生成一种特殊的方法, 它采用修改列表中一个元素而不是整个列表的方式，可以是增加一个元素，也可以是删除一个元素。

在使用@Singular注释注释一个集合字段（使用@Builder注释类），lombok会将该构建器节点视为一个集合，并生成两个adder方法而不是setter方法。

生成代码如下：

```java
public LombokDemo3.LombokDemo3Builder occupation(String occupation) {
    if (this.occupations == null) {
        this.occupations = new ArrayList();
    }

    this.occupations.add(occupation);
    return this;
}

public LombokDemo3.LombokDemo3Builder occupations(Collection<? extends String> occupations) {
    if (occupations == null) {
        throw new NullPointerException("occupations cannot be null");
    } else {
        if (this.occupations == null) {
            this.occupations = new ArrayList();
        }

        this.occupations.addAll(occupations);
        return this;
    }
}

public LombokDemo3.LombokDemo3Builder clearOccupations() {
    if (this.occupations != null) {
        this.occupations.clear();
    }

    return this;
}
```

- Builder.Default

```java
@Builder
@ToString
public class BuilderDefaultExample {

    @Builder.Default
    private final String id = UUID.randomUUID().toString();
    
    private String username;

    @Builder.Default
    private long insertTime = System.currentTimeMillis();

}
```

- `@SneakyThrows`示例

```java
import lombok.SneakyThrows;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
public class Test {
    @SneakyThrows()
    public void read() {
        InputStream inputStream = new FileInputStream("");
    }
    @SneakyThrows
    public void write() {
        throw new UnsupportedEncodingException();
    }
    //相当于
    public void read() throws FileNotFoundException {
        InputStream inputStream = new FileInputStream("");
    }
    public void write() throws UnsupportedEncodingException {
        throw new UnsupportedEncodingException();
    }
}
```

- `@Synchronized`示例

```java
public class SynchronizedDemo {
    @Synchronized
    public static void hello() {
        System.out.println("world");
    }
    //相当于
    private static final Object $LOCK = new Object[0];
    public static void hello() {
        synchronized ($LOCK) {
            System.out.println("world");
        }
    }
}
```

- `@Getter(lazy = true)`示例

```java
public class GetterLazyExample {
    @Getter(lazy = true)
    private final double[] cached = expensive();
    private double[] expensive() {
        double[] result = new double[1000000];
        for (int i = 0; i < result.length; i++) {
            result[i] = Math.asin(i);
        }
        return result;
    }
}

// 相当于如下所示: 

import java.util.concurrent.atomic.AtomicReference;
public class GetterLazyExample {
    private final AtomicReference<java.lang.Object> cached = new AtomicReference<>();
    public double[] getCached() {
        java.lang.Object value = this.cached.get();
        if (value == null) {
            synchronized (this.cached) {
                value = this.cached.get();
                if (value == null) {
                    final double[] actualValue = expensive();
                    value = actualValue == null ? this.cached : actualValue;
                    this.cached.set(value);
                }
            }
        }
        return (double[]) (value == this.cached ? null : value);
    }
    private double[] expensive() {
        double[] result = new double[1000000];
        for (int i = 0; i < result.length; i++) {
            result[i] = Math.asin(i);
        }
        return result;
    }
}
```

## [#](#lombok深入理解) Lombok深入理解

> 接下来我们深入理解下Lombok：

### [#](#lombok解决了什么问题) Lombok解决了什么问题

这个简单，就是简化代码。

### [#](#lombok的原理) Lombok的原理

> 会发现在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？

核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。

- **运行时解析**

运行时能够解析的注解，必须将@Retention设置为RUNTIME, 比如`@Retention(RetentionPolicy.RUNTIME)`，这样就可以通过反射拿到该注解。java.lang,reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。

- **编译时解析**

编译时解析有两种机制，分别简单描述下：

1）Annotation Processing Tool

apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：

- api都在com.sun.mirror非标准包下
- 没有集成到javac中，需要额外运行

2）Pluggable Annotation Processing API

[JSR 269: Pluggable Annotation Processing API在新窗口打开](https://www.jcp.org/en/jsr/proposalDetails?id=269)自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，这时javac执行的过程如下：

![img](./F:/images/develop/package/dev-package-lombok-2.png)

Lombok本质上就是一个实现了“JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：

- javac对源代码进行分析，生成了一棵抽象语法树（AST）
- 运行过程中调用实现了“JSR 269 API”的Lombok程序
- 此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点
- javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）

![img](./F:/images/develop/package/dev-package-lombok-3.png)

从上面的Lombok执行的流程图中可以看出，在Javac 解析成AST抽象语法树之后, Lombok 根据自己编写的注解处理器，动态地修改 AST，增加新的节点（即Lombok自定义注解所需要生成的代码），最终通过分析生成JVM可执行的字节码Class文件。使用Annotation Processing自定义注解是在编译阶段进行修改，而JDK的反射技术是在运行时动态修改，两者相比，反射虽然更加灵活一些但是带来的性能损耗更加大。

### [#](#lombok类似原理工具有什么) Lombok类似原理工具有什么

> 换言之，我们可以通过Lombok同样的思路解决什么问题？ @pdai

- 第一个问题，我可以通过上述原理，自己实现一个类似Lombok 吗？

可以的，给你找了[一篇文章在新窗口打开](https://www.jianshu.com/p/fc06578e805a)

- 还有一些其它类库使用这种方式实现，比如: 
  - [Google Auto在新窗口打开](https://github.com/google/auto)
  - Dagger
  - ...

### [#](#lombok没有未来-java14-record了解下) Lombok没有未来 - Java14 Record了解下

> Lombok是没有未来的，因为Java完全可以对于这种纯数据载体通过另外一种方式表示, 所以有了[JEP 359: Records在新窗口打开](https://openjdk.java.net/jeps/359), 简单而言就是通过一个语法糖来解决。

![img](./F:/images/develop/package/dev-package-lombok-1.png)

- 从前

```java
public class Range {
 
    private final int min;
    private final int max;
 
    public Range(int min, int max) {
        this.min = min;
        this.max = max;
    }
 
    public int getMin() {
        return min;
    }
 
    public int getMax() {
        return max;
    }
 
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Range range = (Range) o;
        return min == range.min && max == range.max;
    }
 
    @Override
    public int hashCode() {
        return Objects.hash(min, max);
    }
 
    @Override
    public String toString() {
        return "Range{" +
          "min=" + min +
          ", max=" + max +
          '}';
    }
}
```

- Java14 record

```java
public record Range(int min, int max) {}
```

没错就是这个简单！这个语法糖是不是有 “卧槽” 的感觉？我们声明这种类使用record 标识（目前不知道 record 会不会上升到关键字的高度）。当你用record 声明一个类时，该类将自动拥有以下功能：

- 获取成员变量的简单方法，以上面代码为例 min() 和 max() 。注意区别于我们平常getter的写法。
- 一个 equals 方法的实现，执行比较时会比较该类的所有成员属性
- 重写 equals 当然要重写 hashCode
- 一个可以打印该类所有成员属性的 toString 方法。
- 请注意只会有一个构造方法。

因为这个特性是 preview feature，默认情况下是无法编译和执行的。同样以上面为例我们需要执行：

```bash
 $ javac -d classes --enable-preview --release 14 Range.java
 $ java -classpath classes --enable-preview Range
```

在 Jshell 中运行

```bash
jshell> Range r = new Range(10, 20);
r ==> Range[min=10, max=20]
jshell> r.min()
$5 ==> 10
jshell> r.toString()
$6 ==> "Range[min=10, max=20]"
jshell> r
r ==> Range[min=10, max=20]
```

虽然 record 声明的类没有 final 关键字，实际上它是一个不可变类。除了一些限制外，它依旧是一个普通的Java 类。因此，我们可以像添加普通类一样添加逻辑。我们可以在构造实例时强制执行前提条件：

```java
public record Range(int min, int max) {
    public Range {
        if (min >= max)
            throw new IllegalArgumentException("min should be less than max");
    }
}
```

另外我们也可以给 Records 类增加普通方法、静态属性、静态方法，这里不再举例；

**为了简化语法糖的推理，不能在类内声明成员属性**。以下是错误的示范：

```java
public record Range(int min, int max) {
    // 错误的示范
    private String name;
}
```

## [#](#lombok有什么坑) Lombok有什么坑

> 谈谈Lombok容易被忽视的坑, 看似代码简洁背后的代价。@pdai

### [#](#data的坑) `@Data`的坑

在使用Lombok过程中，如果对于各种注解的底层原理不理解的话，很容易产生意想不到的结果。

举一个简单的例子，我们知道，当我们使用`@Data`定义一个类的时候，会自动帮我们生成`equals()`方法 。

但是如果只使用了`@Data`，而不使用`@EqualsAndHashCode(callSuper=true)`的话，会默认是`@EqualsAndHashCode(callSuper=false)`,这时候生成的`equals()`方法只会比较子类的属性，不会考虑从父类继承的属性，无论父类属性访问权限是否开放。

这就可能得到意想不到的结果。

### [#](#代码可读性-可调试性低) 代码可读性，可调试性低

在代码中使用了Lombok，确实可以帮忙减少很多代码，因为Lombok会帮忙自动生成很多代码。但是**这些代码是要在编译阶段才会生成的**，所以在开发的过程中，其实很多代码其实是缺失的。

在代码中大量使用Lombok，就导致代码的可读性会低很多，而且也会给代码调试带来一定的问题。 比如，我们想要知道某个类中的某个属性的getter方法都被哪些类引用的话，就没那么简单了。

### [#](#lombok有很强的侵入性) Lombok有很强的侵入性

- **强J队友**

因为Lombok的使用要求开发者一定要在IDE中安装对应的插件。如果未安装插件的话，使用IDE打开一个基于Lombok的项目的话会提示找不到方法等错误。导致项目编译失败。也就是说，如果项目组中有一个人使用了Lombok，那么其他人就必须也要安装IDE插件。否则就没办法协同开发。

更重要的是，如果我们定义的一个jar包中使用了Lombok，那么就要求所有依赖这个jar包的所有应用都必须安装插件，这种侵入性是很高的。

- **影响升级**

因为Lombok对于代码有很强的侵入性，就可能带来一个比较大的问题，那就是会影响我们对JDK的升级。按照如今JDK的升级频率，每半年都会推出一个新的版本，但是Lombok作为一个第三方工具，并且是由开源团队维护的，那么他的迭代速度是无法保证的。

所以，如果我们需要升级到某个新版本的JDK的时候，若其中的特性在Lombok中不支持的话就会受到影响。

还有一个可能带来的问题，就是Lombok自身的升级也会受到限制。因为一个应用可能依赖了多个jar包，而每个jar包可能又要依赖不同版本的Lombok，这就导致在应用中需要做版本仲裁，而我们知道，jar包版本仲裁是没那么容易的，而且发生问题的概率也很高。

### [#](#lombok破坏了封装性) Lombok破坏了封装性

以上几个问题，我认为都是有办法可以避免的。但是有些人排斥使用Lombok还有一个重要的原因，那就是他会破坏封装性。

众所周知，Java的三大特性包括`封装性`、`继承性`和`多态性`。

如果我们在代码中直接使用Lombok，那么他会自动帮我们生成getter、setter 等方法，这就意味着，一个类中的所有参数都自动提供了设置和读取方法。

举个简单的例子，我们定义一个购物车类：

```java
@Data
public class ShoppingCart { 

    //商品数目
    private int itemsCount; 

    //总价格
    private double totalPrice; 

    //商品明细
    private List items = new ArrayList<>();

}

//例子来源于《极客时间-设计模式之美》
```

我们知道，购物车中商品数目、商品明细以及总价格三者之前其实是有关联关系的，如果需要修改的话是要一起修改的。

但是，我们使用了Lombok的`@Data`注解，对于itemsCount 和 totalPrice这两个属性。虽然我们将它们定义成 `private` 类型，但是提供了 `public` 的 `getter`、`setter` 方法。

外部可以通过 `setter` 方法随意地修改这两个属性的值。我们可以随意调用 `setter` 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。

而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。

好的做法应该是不提供`getter/setter`，而是只提供一个public的addItem方法，同时去修改itemsCount、totalPrice以及items三个属性。

> 以上问题其实也是可以解决的，但这提醒了我们需要理解Lombok，而不是一股脑的用`@Data`注解。 @pdai

## [#](#总结) 总结

- 优缺点
  - 优点：大大减少了代码量，使代码非常简洁
  - 缺点：可能存在对队友不友好、对代码不友好、对调试不友好、对升级不友好等问题。Lombok还会导致破坏封装性的问题。`@Data`中覆盖`equals`和`hashCode`的坑等。
- 什么样的情况使用Lombok
  - 团队整体的共识，IDE规范，相关代码规范等
  - 对Lombok足够了解，比如知道其中的坑等
- 不推荐使用Lombok的理由
  - 其实我们不缺时间写Getter和Setter的，这些代码通常是由IDE生成的。简化也是有代价的。
  - 对Lombok认知不够，导致带来的坑。
  - Java14中Record了解下。

### redis

```java
 
/**
 * @className: RedisUtil
 * @description:
 * @author: sh.Liu
 * @date: 2022-03-09 14:07
 */
@Component
public class RedisUtil {
 
    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 给一个指定的 key 值附加过期时间
     *
     * @param key
     * @param time
     * @return
     */
    public boolean expire(String key, long time) {
        return redisTemplate.expire(key, time, TimeUnit.SECONDS);
    }
    /**
     * 根据key 获取过期时间
     *
     * @param key
     * @return
     */
    public long getTime(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }
    /**
     * 根据key 获取过期时间
     *
     * @param key
     * @return
     */
    public boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }
    /**
     * 移除指定key 的过期时间
     *
     * @param key
     * @return
     */
    public boolean persist(String key) {
        return redisTemplate.boundValueOps(key).persist();
    }
 
    //- - - - - - - - - - - - - - - - - - - - -  String类型 - - - - - - - - - - - - - - - - - - - -
 
    /**
     * 根据key获取值
     *
     * @param key 键
     * @return 值
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }
 
    /**
     * 将值放入缓存
     *
     * @param key   键
     * @param value 值
     * @return true成功 false 失败
     */
    public void set(String key, String value) {
        redisTemplate.opsForValue().set(key, value);
    }
 
    /**
     * 将值放入缓存并设置时间
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒) -1为无期限
     * @return true成功 false 失败
     */
    public void set(String key, String value, long time) {
        if (time > 0) {
            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
        } else {
            redisTemplate.opsForValue().set(key, value);
        }
    }
 
    /**
     * 批量添加 key (重复的键会覆盖)
     *
     * @param keyAndValue
     */
    public void batchSet(Map<String, String> keyAndValue) {
        redisTemplate.opsForValue().multiSet(keyAndValue);
    }
 
    /**
     * 批量添加 key-value 只有在键不存在时,才添加
     * map 中只要有一个key存在,则全部不添加
     *
     * @param keyAndValue
     */
    public void batchSetIfAbsent(Map<String, String> keyAndValue) {
        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);
    }
 
    /**
     * 对一个 key-value 的值进行加减操作,
     * 如果该 key 不存在 将创建一个key 并赋值该 number
     * 如果 key 存在,但 value 不是长整型 ,将报错
     *
     * @param key
     * @param number
     */
    public Long increment(String key, long number) {
        return redisTemplate.opsForValue().increment(key, number);
    }
 
    /**
     * 对一个 key-value 的值进行加减操作,
     * 如果该 key 不存在 将创建一个key 并赋值该 number
     * 如果 key 存在,但 value 不是 纯数字 ,将报错
     *
     * @param key
     * @param number
     */
    public Double increment(String key, double number) {
        return redisTemplate.opsForValue().increment(key, number);
    }
 
    //- - - - - - - - - - - - - - - - - - - - -  set类型 - - - - - - - - - - - - - - - - - - - -
 
    /**
     * 将数据放入set缓存
     *
     * @param key 键
     * @return
     */
    public void sSet(String key, String value) {
        redisTemplate.opsForSet().add(key, value);
    }
 
    /**
     * 获取变量中的值
     *
     * @param key 键
     * @return
     */
    public Set<Object> members(String key) {
        return redisTemplate.opsForSet().members(key);
    }
 
    /**
     * 随机获取变量中指定个数的元素
     *
     * @param key   键
     * @param count 值
     * @return
     */
    public void randomMembers(String key, long count) {
        redisTemplate.opsForSet().randomMembers(key, count);
    }
 
    /**
     * 随机获取变量中的元素
     *
     * @param key 键
     * @return
     */
    public Object randomMember(String key) {
        return redisTemplate.opsForSet().randomMember(key);
    }
 
    /**
     * 弹出变量中的元素
     *
     * @param key 键
     * @return
     */
    public Object pop(String key) {
        return redisTemplate.opsForSet().pop("setValue");
    }
 
    /**
     * 获取变量中值的长度
     *
     * @param key 键
     * @return
     */
    public long size(String key) {
        return redisTemplate.opsForSet().size(key);
    }
 
    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key, Object value) {
        return redisTemplate.opsForSet().isMember(key, value);
    }
 
    /**
     * 检查给定的元素是否在变量中。
     *
     * @param key 键
     * @param obj 元素对象
     * @return
     */
    public boolean isMember(String key, Object obj) {
        return redisTemplate.opsForSet().isMember(key, obj);
    }
 
    /**
     * 转移变量的元素值到目的变量。
     *
     * @param key     键
     * @param value   元素对象
     * @param destKey 元素对象
     * @return
     */
    public boolean move(String key, String value, String destKey) {
        return redisTemplate.opsForSet().move(key, value, destKey);
    }
 
    /**
     * 批量移除set缓存中元素
     *
     * @param key    键
     * @param values 值
     * @return
     */
    public void remove(String key, Object... values) {
        redisTemplate.opsForSet().remove(key, values);
    }
 
    /**
     * 通过给定的key求2个set变量的差值
     *
     * @param key     键
     * @param destKey 键
     * @return
     */
    public Set<Set> difference(String key, String destKey) {
        return redisTemplate.opsForSet().difference(key, destKey);
    }
 
 
    //- - - - - - - - - - - - - - - - - - - - -  hash类型 - - - - - - - - - - - - - - - - - - - -
 
    /**
     * 加入缓存
     *
     * @param key 键
     * @param map 键
     * @return
     */
    public void add(String key, Map<String, String> map) {
        redisTemplate.opsForHash().putAll(key, map);
    }
 
    /**
     * 获取 key 下的 所有  hashkey 和 value
     *
     * @param key 键
     * @return
     */
    public Map<Object, Object> getHashEntries(String key) {
        return redisTemplate.opsForHash().entries(key);
    }
 
    /**
     * 验证指定 key 下 有没有指定的 hashkey
     *
     * @param key
     * @param hashKey
     * @return
     */
    public boolean hashKey(String key, String hashKey) {
        return redisTemplate.opsForHash().hasKey(key, hashKey);
    }
 
    /**
     * 获取指定key的值string
     *
     * @param key  键
     * @param key2 键
     * @return
     */
    public String getMapString(String key, String key2) {
        return redisTemplate.opsForHash().get("map1", "key1").toString();
    }
 
    /**
     * 获取指定的值Int
     *
     * @param key  键
     * @param key2 键
     * @return
     */
    public Integer getMapInt(String key, String key2) {
        return (Integer) redisTemplate.opsForHash().get("map1", "key1");
    }
 
    /**
     * 弹出元素并删除
     *
     * @param key 键
     * @return
     */
    public String popValue(String key) {
        return redisTemplate.opsForSet().pop(key).toString();
    }
 
    /**
     * 删除指定 hash 的 HashKey
     *
     * @param key
     * @param hashKeys
     * @return 删除成功的 数量
     */
    public Long delete(String key, String... hashKeys) {
        return redisTemplate.opsForHash().delete(key, hashKeys);
    }
 
    /**
     * 给指定 hash 的 hashkey 做增减操作
     *
     * @param key
     * @param hashKey
     * @param number
     * @return
     */
    public Long increment(String key, String hashKey, long number) {
        return redisTemplate.opsForHash().increment(key, hashKey, number);
    }
 
    /**
     * 给指定 hash 的 hashkey 做增减操作
     *
     * @param key
     * @param hashKey
     * @param number
     * @return
     */
    public Double increment(String key, String hashKey, Double number) {
        return redisTemplate.opsForHash().increment(key, hashKey, number);
    }
 
    /**
     * 获取 key 下的 所有 hashkey 字段
     *
     * @param key
     * @return
     */
    public Set<Object> hashKeys(String key) {
        return redisTemplate.opsForHash().keys(key);
    }
 
    /**
     * 获取指定 hash 下面的 键值对 数量
     *
     * @param key
     * @return
     */
    public Long hashSize(String key) {
        return redisTemplate.opsForHash().size(key);
    }
 
    //- - - - - - - - - - - - - - - - - - - - -  list类型 - - - - - - - - - - - - - - - - - - - -
 
    /**
     * 在变量左边添加元素值
     *
     * @param key
     * @param value
     * @return
     */
    public void leftPush(String key, Object value) {
        redisTemplate.opsForList().leftPush(key, value);
    }
 
    /**
     * 获取集合指定位置的值。
     *
     * @param key
     * @param index
     * @return
     */
    public Object index(String key, long index) {
        return redisTemplate.opsForList().index("list", 1);
    }
 
    /**
     * 获取指定区间的值。
     *
     * @param key
     * @param start
     * @param end
     * @return
     */
    public List<Object> range(String key, long start, long end) {
        return redisTemplate.opsForList().range(key, start, end);
    }
 
    /**
     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，
     * 如果中间参数值存在的话。
     *
     * @param key
     * @param pivot
     * @param value
     * @return
     */
    public void leftPush(String key, String pivot, String value) {
        redisTemplate.opsForList().leftPush(key, pivot, value);
    }
 
    /**
     * 向左边批量添加参数元素。
     *
     * @param key
     * @param values
     * @return
     */
    public void leftPushAll(String key, String... values) {
//        redisTemplate.opsForList().leftPushAll(key,"w","x","y");
        redisTemplate.opsForList().leftPushAll(key, values);
    }
 
    /**
     * 向集合最右边添加元素。
     *
     * @param key
     * @param value
     * @return
     */
    public void leftPushAll(String key, String value) {
        redisTemplate.opsForList().rightPush(key, value);
    }
 
    /**
     * 向左边批量添加参数元素。
     *
     * @param key
     * @param values
     * @return
     */
    public void rightPushAll(String key, String... values) {
        //redisTemplate.opsForList().leftPushAll(key,"w","x","y");
        redisTemplate.opsForList().rightPushAll(key, values);
    }
 
    /**
     * 向已存在的集合中添加元素。
     *
     * @param key
     * @param value
     * @return
     */
    public void rightPushIfPresent(String key, Object value) {
        redisTemplate.opsForList().rightPushIfPresent(key, value);
    }
 
    /**
     * 向已存在的集合中添加元素。
     *
     * @param key
     * @return
     */
    public long listLength(String key) {
        return redisTemplate.opsForList().size(key);
    }
 
    /**
     * 移除集合中的左边第一个元素。
     *
     * @param key
     * @return
     */
    public void leftPop(String key) {
        redisTemplate.opsForList().leftPop(key);
    }
 
    /**
     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。
     *
     * @param key
     * @return
     */
    public void leftPop(String key, long timeout, TimeUnit unit) {
        redisTemplate.opsForList().leftPop(key, timeout, unit);
    }
 
    /**
     * 移除集合中右边的元素。
     *
     * @param key
     * @return
     */
    public void rightPop(String key) {
        redisTemplate.opsForList().rightPop(key);
    }
 
    /**
     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。
     *
     * @param key
     * @return
     */
    public void rightPop(String key, long timeout, TimeUnit unit) {
        redisTemplate.opsForList().rightPop(key, timeout, unit);
    }
}
```

