# 二、基本语法



## 2.1 程序的结构

C 语言的源代码文件，通常以后缀名`.c`结尾。下面是一个简单的 C 程序`hello.c`。它就是一个普通的文本文件，任何文本编译器都能用来写。

::: tip

所有的符号一律采用英文符号！

:::

```c
#include <stdio.h>

int main(void) {
  // 打印 Hello World
  printf("Hello World\n");
  return 0;
}
```

- `#include <stdio.h>`：预处理器，加载头文件`stdio.h`。
- `int main(){}`：主函数，返回值为int型，小括号为形参，大括号为函数体。
- `printf("Hello World\n");`：printf关键字，作用是打印。`"Hello World\n"`是字符串。
- `return 0;`：return关键字，返回值。每个语句结尾要加`;`代表语句结束。

## 2.2 注释

注释在C语言程序中不参与编译。是一种对程序的解释说明。也就是说，注释对实际代码没有影响。

C 语言的注释有两种表示方法。

```c
// 这是单行注释，只在一行有效，也可放在语句尾部

/*我是多行注释
可以换行
在多行有效*/
```

## 2.3 标识符和关键字

### 标识符

在编程语言中，标识符是用户编程时使用的名字，变量、常量、函数、语句块都有名字。是用来标识某个实体的一个符号，是对变量名、函数名、标号和其他各种用户定义的对象命名。

C语言中标识符的命名规范：

- 标识符由字母（包括大写和小写）、数字和下划线（`_`）组成，并且首字母不能是数字。
- 不能把C的关键字作为用户的标识符，不能重复标识。
- 标识符长度是由机器上的编译系统决定的，一般的限制为8字符。
- 标识符对大小写敏感，即严格区分大小写。一般对变量名用小写，符号常量命名用大写。
- 标识符命名应做到"见名知意"。



### 关键字

C语言的关键字，是C语言保留的一些有特殊作用词语。一共有32个关键字，

| 关键字   | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| auto     | 声明自动变量                                                 |
| double   | 声明双精度变量或函数                                         |
| typedef  | 用以给数据类型取别名                                         |
| register | 声明寄存器变量                                               |
| short    | 声明短整型变量或函数                                         |
| char     | 声明字符型变量或函数                                         |
| const    | 声明只读变量                                                 |
| static   | 声明静态变量int声明整型变量或函数                            |
| struct   | 声明结构体变量或函数                                         |
| unsigned | 声明无符号类型变量或函数                                     |
| volatile | 说明变量在程序执行中可被隐含地改变long声明长整型变量或函数   |
| union    | 声明共用数据类型                                             |
| signed   | 声明有符号类型变量或函数                                     |
| void     | 声明函数无返回值或无参数，声明无类型指针float声明浮点型变量或函数 |
| enum     | 声明枚举类型                                                 |
| extern   | 声明变量是在其他文件正声明                                   |
| if       | 条件语句                                                     |
| else     | 条件语句否定分支（与 if 连用）                               |
| switch   | 用于开关语句                                                 |
| case     | 开关语句分支                                                 |
| for      | 一种循环语句do循环语句的循环体                               |
| while    | 循环语句的循环条件                                           |
| goto     | 无条件跳转语句                                               |
| continue | 结束当前循环，开始下一轮循环break跳出当前循环                |
| default  | 开关语句中的"其他"分支                                       |
| sizeof   | 计算数据类型长度                                             |
| return   | 子程序返回语句（可以带参数，也可不带参数）循环条件           |



## 2.4 变量和常量

变量名在 C 语言里面属于标识符（identifier），命名有严格的规范。

### 变量的声明

C 语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。

每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。

```
int height;
```

如果几个变量具有相同类型，可以在同一行声明。

```
int height, width;

// 等同于
int height;
int width;
```

注意，声明变量的语句必须以分号结尾。

一旦声明，变量的类型就不能在运行时修改。

### 变量的赋值

C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。

变量的值应该与类型一致，不应该赋予不是同一个类型的值，比如`num`的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致。

赋值操作通过赋值运算符（`=`）完成。

变量的声明和赋值，也可以写在一行。

```c
int num;
num = 42;
```

```c
int num = 42;
```



```
多个相同类型变量的赋值，可以写在同一行。
int x = 1, y = 2;
```

注意，赋值表达式有返回值，等于等号右边的值。

由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。

```
int x, y, z, m, n;

x = y = z = m = n = 3;
```

上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为`n`赋值，然后依次为`m`、`z`、`y`和`x`赋值。

C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边，比如`x = 1`是合法的表达式，但是`1 = x`就会报错。

### 变量的作用域

作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。

文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。

上面示例中，变量`x`是在文件顶层声明的，从声明位置开始的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数`main()`内部就可以读取这个变量。

```
int x = 1;

int main(void) {
  printf("%i\n", x);
}
```

块作用域（block scope）指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。

```
int a = 12;

if (a == 12) {
  int b = 99;
  printf("%d %d\n", a, b);  // 12 99
}

printf("%d\n", a);  // 12
printf("%d\n", b);  // 出错
```

代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。上面示例中，内层和外层都有一个变量`i`，每个作用域都会优先使用当前作用域声明的`i`。

```
{
  int i = 10;

  {
    int i = 20;
    printf("%d\n", i);  // 20
  }

  printf("%d\n", i);  // 10
}
```

### 常量



**常量**是固定值，在程序执行期间不会改变。相比于变量，只不过常量的值在定义后不能进行修改。

整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

```c
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */


int myInt = 10;
long myLong = 100000L;
unsigned int myUnsignedInt = 10U;
```



### 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点常量的实例：

```c
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */

float myFloat = 3.14f;
double myDouble = 3.14159;
```



### 字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符                 |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |

```c
char myChar = 'a';
int myAsciiValue = (int) myChar; *// 将 myChar 转换为 ASCII 值 97*
```

### 字符串常量

字符串字面值或常量是括在双引号 **" "** 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

```c
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"

字符串常量在内存中以 **null** 终止符 **\0** 结尾。例如：
char myString[] = "Hello, world!"; //系统对字符串常量自动加一个 '\0'
```



### 定义常量

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。
2. 使用 **const** 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。

### #define 预处理器

下面是使用 #define 预处理器定义常量的形式：

```
#define 常量名 常量值
```

下面的代码定义了一个名为 PI 的常量：

```
#define PI 3.14159
```

在程序中使用该常量时，编译器会将所有的 PI 替换为 3.14159。

具体请看下面的实例：

```c
#include <stdio.h>
#define LENGTH 10
#define WIDTH  5
#define NEWLINE '\n'
int main() {
    int area;
    area = LENGTH * WIDTH;
    printf("value of area : %d", area); 
    printf("%c", NEWLINE);
    return 0; 
}
value of area : 50
```

### const 关键字

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```
const 数据类型 常量名 = 常量值;
```

下面的代码定义了一个名为MAX_VALUE的常量：

```
const int MAX_VALUE = 100;
```

在程序中使用该常量时，其值将始终为100，并且不能被修改。

const 声明常量要在一个语句内完成：

当上面的代码被编译和执行时，它会产生下列结果：

请注意，把常量定义为大写字母形式，是一个很好的编程习惯。

```c
#include <stdio.h>
int main() {
    const int  LENGTH = 10;
    const int  WIDTH  = 5;
    const char NEWLINE = '\n';
    int area;
    area = LENGTH * WIDTH;
    printf("value of area : %d", area);
    printf("%c", NEWLINE);
    return 0; 
}
value of area : 50
```



### #define 与 const 区别

\#define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。

\#define 预处理指令和 const 关键字在定义常量时有一些区别：

- 替换机制：`#define` 是进行简单的文本替换，而 `const` 是声明一个具有类型的常量。`#define` 定义的常量在编译时会被直接替换为其对应的值，而 `const` 定义的常量在程序运行时会分配内存，并且具有类型信息。
- 类型检查：`#define` 不进行类型检查，因为它只是进行简单的文本替换。而 `const` 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。
- 作用域：`#define` 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 `const` 定义的常量具有块级作用域，只在其定义所在的作用域内有效。
- 调试和符号表：使用 `#define` 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 `const` 定义的常量会在符号表中有相应的条目，有助于调试和可读性。

## 2.5 输入和输出

当我们提到**输入**时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。

当我们提到**输出**时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。

### 标准文件

C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。

| 标准文件 | 文件指针 | 设备     |
| :------- | :------- | :------- |
| 标准输入 | stdin    | 键盘     |
| 标准输出 | stdout   | 屏幕     |
| 标准错误 | stderr   | 您的屏幕 |

文件指针是访问文件的方式，本节将讲解如何从键盘上读取值以及如何把结果输出到屏幕上。

C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。

scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。

```c
#include <stdio.h> // 执行 printf() 函数需要该库 
int main() {
    printf("菜鸟教程");
    //显示引号中的内容    
    return 0; 
}
```

**实例解析：**

- 所有的 C 语言程序都需要包含 **main()** 函数。 代码从 **main()** 函数开始执行。
- **printf()** 用于格式化输出到屏幕。**printf()** 函数在 **"stdio.h"** 头文件中声明。
- **stdio.h** 是一个头文件 (标准输入输出头文件) and **#include** 是一个预处理命令，用来引入头文件。 当编译器遇到 **printf()** 函数时，如果没有找到 **stdio.h** 头文件，会发生编译错误。
- **return 0;** 语句用于表示退出程序。

### %d 格式化输出整数

```c
#include <stdio.h> 
int main() {
    int testInteger = 5;
    printf("Number = %d", testInteger);
    return 0; }
Number = 5
```

在 printf() 函数的引号中使用 "%d" (整型) 来匹配整型变量 testInteger 并输出到屏幕。

### %f 格式化输出浮点型数据

```c
#include <stdio.h>
int main() {
    float f;
    printf("Enter a number: ");
    // %f 匹配浮点型数据    scanf("%f",&f);    
    printf("Value = %f", f);
    return 0;
}
```



### getchar() & putchar() 函数

**int getchar(void)** 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

**int putchar(int c)** 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：

```c
#include <stdio.h>
int main( ) {
    int c;
    printf( "Enter a value :");
    c = getchar( );
    printf( "\nYou entered: ");
    putchar( c );
    printf( "\n");
    return 0;
}
$./a.out
    Enter a value :runoob

        You entered: r
```

### gets() & puts() 函数

**char \*gets(char \*s)** 函数从 **stdin** 读取一行到 **s** 所指向的缓冲区，直到一个终止符或 EOF。

**int puts(const char \*s)** 函数把字符串 s 和一个尾随的换行符写入到 **stdout**。



当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：

```c
#include <stdio.h>
int main( ) {
    char str[100];
    printf( "Enter a value :");
    gets( str );
    printf( "\nYou entered: ");
    puts( str );
    return 0;
}


$./a.out
Enter a value :runoob

You entered: runoob
```

### scanf() 和 printf() 函数

**int scanf(const char \*format, ...)** 函数从标准输入流 **stdin** 读取输入，并根据提供的 **format** 来浏览输入。

**int printf(const char \*format, ...)** 函数把输出写入到标准输出流 **stdout** ，并根据提供的格式产生输出。

**format** 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：



代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：

```c
#include <stdio.h>
int main( ) {
    char str[100];
    int i;
    printf( "Enter a value :");
    scanf("%s %d", str, &i);
    printf( "\nYou entered: %s %d ", str, i);
    printf("\n");
    return 0;
}

$./a.out
Enter a value :runoob 123

You entered: runoob 123 
```

在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 "string integer"，如果您提供的是 "string string" 或 "integer integer"，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串。

## 2.6 预处理器

C 语言编译器在编译程序之前，会先使用预处理器处理代码。预处理指令一般放在代码的开头部分。每个预处理指令都以`#`开头，放在一行的行首。所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。

| 指令               | 作用                                                         |      |
| ------------------ | ------------------------------------------------------------ | ---- |
| #define            | 最常见的预处理指令，用来将指定的词替换成另一个词。           |      |
| `#undef`           | 用来取消已经使用`#define`定义的宏。                          |      |
| #include           | 用于编译时将其他源码文件，加载进入当前文件。                 |      |
| `#if...#endif`     | 用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。 |      |
| `#ifdef...#endif`  | 用于判断某个宏是否定义过。                                   |      |
| `#ifndef...#endif` | 用来判断，如果某个宏没有被定义过，则执行指定的操作。         |      |
| `#line`            | 用于覆盖预定义宏`__LINE__`，将其改为自定义的行号。后面的行将从`__LINE__`的新值开始计数。 |      |
| `#error`           | 用于让预处理器抛出一个错误，终止编译。                       |      |
| `#pragma`          | 用来修改编译器属性。                                         |      |

### #define

`#define`是最常见的预处理指令，用来将指定的词替换成另一个词。第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。

`#define`指定将源码里面的`MAX`，全部替换成`100`。`MAX`就称为一个宏。

宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（`_`），且首字符不能是数字。

宏是原样替换，指定什么内容，就一模一样替换成什么内容。

`#define`允许多重替换，即一个宏可以包含另一个宏。

宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。

```
#define MAX 100
```

```
#define TWO 2
#define FOUR TWO*TWO
```

上面示例中，`FOUR`会被替换成`2*2`。

注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。

同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。

### 带参数的宏

宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。

这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。

宏的参数也可以是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。

带参数的宏也可以嵌套，一个宏里面包含另一个宏。

```
#define SQUARE(X) X*X
```

```
// 替换成 z = 2*2;
z = SQUARE(2);
```

```
#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
#define QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
#define QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)
```





### `#`运算符，`##`运算符

由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上`#`。

```
#define STR(x) #x

// 等同于 printf("%s\n", "3.14159");
printf("%s\n", STR(3.14159));
```

如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用`##`运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。

```
#define MK_ID(n) i##n
int MK_ID(1), MK_ID(2), MK_ID(3);
// 替换成
int i1, i2, i3;
```

### 不定参数的宏

宏的参数还可以是不定数量的（即不确定有多少个参数），`...`表示剩余的参数。

注意，`...`只能替代宏的尾部参数。

```
#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__
```



### #undef

`#undef`指令用来取消已经使用`#define`定义的宏。

有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用`#undef`取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而`#undef`的参数如果是不存在的宏，并不会报错。

```
#define LIMIT 400
#undef LIMIT
```



### #include

`#include`指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。

形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。

形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。

`#include`最常见的用途，就是用来加载包含函数原型的头文件（后缀名为`.h`）

```
// 形式一
#include <foo.h> // 加载系统提供的文件

// 形式二
#include "foo.h" // 加载用户提供的文件

#include "/usr/local/lib/foo.h"
```



### #if...#endif

`#if...#endif`指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。

`#if`后面的`0`，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。`#if 0`这种写法常用来当作注释使用，不需要的代码就放在`#if 0`里面。

`#if`后面的判断条件，通常是一个表达式。如果表达式的值不等于`0`，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。

`#if...#endif`之间还可以加入`#else`指令，用于指定判断条件不成立时，需要编译的语句。

```
#if 0
  const double pi = 3.1415; // 不会执行
#endif
```

如果有多个判断条件，还可以加入`#elif`命令。

```
#if HAPPY_FACTOR == 0
  printf("I'm not happy!\n");
#elif HAPPY_FACTOR == 1
  printf("I'm just regular\n");
#else
  printf("I'm extra happy!\n");
#endif
```

上面示例中，通过`#elif`指定了第二重判断。注意，`#elif`的位置必须在`#else`之前。如果多个判断条件皆不满足，则执行`#else`的部分。

没有定义过的宏，等同于`0`。因此如果`UNDEFINED`是一个没有定义过的宏，那么`#if UNDEFINED`为伪，而`#if !UNDEFINED`为真。

`#if`的常见应用就是打开（或关闭）调试模式。

上面示例中，通过将`DEBUG`设为`1`，就打开了调试模式，可以输出调试信息。

```
#define DEBUG 1

#if DEBUG
printf("value of i : %d\n", i);
printf("value of j : %d\n", j);
#endif
```





### #ifdef...#endif

`#ifdef...#endif`指令用于判断某个宏是否定义过。

有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用`#define`定义一个空的宏。通过这个宏，判断库文件是否被加载了。

```
#define EXTRA_HAPPY

#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#endif
```

`#ifdef`可以与`#else`指令配合使用。

```
#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#else
  printf("I'm just regular\n");
#endif
```

`#ifdef...#else...#endif`可以用来实现条件加载。

```
#ifdef MAVIS
  #include "foo.h"
  #define STABLES 1
#else
  #include "bar.h"
  #define STABLES 2
#endif
```

### defined 运算符

上一节的`#ifdef`指令，等同于`#if defined`。

```
#ifdef FOO
// 等同于
#if defined FOO
```

上面示例中，`defined`是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。

使用这种语法，可以完成多重判断。

```
#if defined FOO
  x = 2;
#elif defined BAR
  x = 3;
#endif
```

这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。

```
#if defined IBMPC
  #include "ibmpc.h"
#elif defined MAC
  #include "mac.h"
#else
  #include "general.h"
#endif
```

### #ifndef...#endif

`#ifndef...#endif`指令跟`#ifdef...#endif`正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。

```
#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#endif

#ifndef EXTRA_HAPPY
  printf("I'm just regular\n");
#endif
```

`#ifndef`常用于防止重复加载。举例来说，为了防止头文件`myheader.h`被重复加载，可以把它放在`#ifndef...#endif`里面加载。

```
#ifndef MYHEADER_H
  #define MYHEADER_H
  #include "myheader.h"
#endif
```

`#ifndef`等同于`#if !defined`。

### 预定义宏

C 语言提供一些预定义的宏，可以直接使用。

- `__DATE__`：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。
- `__TIME__`：编译时间，格式为“hh:mm:ss”。
- `__FILE__`：当前文件名。
- `__LINE__`：当前行号。
- `__func__`：当前正在执行的函数名。该预定义宏必须在函数作用域使用。
- `__STDC__`：如果被设为1，表示当前编译器遵循 C 标准。
- `__STDC_HOSTED__`：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。
- `__STDC_VERSION__`：编译所使用的 C 语言版本，是一个格式为`yyyymmL`的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。

下面示例打印这些预定义宏的值。

```
#include <stdio.h>

int main(void) {
  printf("This function: %s\n", __func__);
  printf("This file: %s\n", __FILE__);
  printf("This line: %d\n", __LINE__);
  printf("Compiled on: %s %s\n", __DATE__, __TIME__);
  printf("C Version: %ld\n", __STDC_VERSION__);
}

/* 输出如下

This function: main
This file: test.c
This line: 7
Compiled on: Mar 29 2021 19:19:37
C Version: 201710

*/
```

### #line

`#line`指令用于覆盖预定义宏`__LINE__`，将其改为自定义的行号。后面的行将从`__LINE__`的新值开始计数。

```
// 将下一行的行号重置为 300
#line 300
```

`#line`还可以改掉预定义宏`__FILE__`，将其改为自定义的文件名。

```
#line 300 "newfilename"
```

上面示例中，下一行的行号重置为`300`，文件名重置为`newfilename`。

### #error

`#error`指令用于让预处理器抛出一个错误，终止编译。

```
#if __STDC_VERSION__ != 201112L
  #error Not C11
#endif
```

上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。

### #pragma

`#pragma`指令用来修改编译器属性。

```
// 使用 C99 标准
#pragma c9x on
```
