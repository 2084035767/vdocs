# C语言笔记

## 一、介绍

### 1.1 C语言的历史

C 语言最初是作为 Unix 系统的开发工具而发明的。

1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了 Unix 操作系统。Unix 是用汇编语言写的，无法移植到其他计算机，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 B 语言。

1972年，丹尼斯·里奇和布莱恩·柯林汉（Brian Kernighan）又在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，所以称为 C 语言。

1973年，整个 Unix 系统都使用 C 语言重写。此后，这种语言开始快速流传，广泛用于各种操作系统和系统软件的开发。

1988年，美国国家标准协会（ANSI）正式将 C 语言标准化，标志着 C 语言开始稳定和规范化。

几十年后的今天，C 语言依然是最广泛使用、最流行的系统编程语言之一，Unix 和 Linux 系统现在还是使用 C 语言开发。

### 1.2 C语言的特点

C 语言能够长盛不衰、广泛应用，主要原因是它有一些鲜明的特点。

1. 低级语言：C 语言能够直接操作硬件、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，也就是低级语言

2. 可移植性：C 程序可以相对简单地移植到各种硬件架构和操作系统。

3. 简单性：C 语言的语法相对简单，语法规则不算太多，也几乎没有语法糖。

4. 灵活性C 语言对程序员的限制很少。它假设程序员知道自己在干嘛，不会限制你做各种危险的操作，你干什么都可以，后果也由自己负责。



此外，当代很多流行语言都是以 C 语言为基础，比如 C++、Java、C#、JavaScript 等等。学好 C 语言有助于对这些语言加深理解。

### 1.3 编译过程

C 语言是一种编译型语言，源码都是文本文件，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。

目前，最常见的 C 语言编译器是自由软件基金会推出的 GCC 编译器，它可以免费使用。本书也使用这个编译器。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 MinGW。但是，也可以不用这么麻烦，网上有在线编译器，能够直接在网页上模拟运行 C 代码，查看结果，下面就是两个这样的工具。

## 二、基本语法

### 2.1 程序的结构

C 语言的源代码文件，通常以后缀名`.c`结尾。下面是一个简单的 C 程序`hello.c`。它就是一个普通的文本文件，任何文本编译器都能用来写。

::: tip

所有的符号一律采用英文符号！

:::

```c
#include <stdio.h>

int main(void) {
  // 打印 Hello World
  printf("Hello World\n");
  return 0;
}
```

- `#include <stdio.h>`：预处理器，加载头文件`stdio.h`。
- `int main(){}`：主函数，返回值为int型，小括号为形参，大括号为函数体。
- `printf("Hello World\n");`：printf关键字，作用是打印。`"Hello World\n"`是字符串。
- `return 0;`：return关键字，返回值。每个语句结尾要加`;`代表语句结束。

### 2.2 注释

注释在C语言程序中不参与编译。是一种对程序的解释说明。也就是说，注释对实际代码没有影响。

C 语言的注释有两种表示方法。

```c
// 这是单行注释，只在一行有效，也可放在语句尾部

/*我是多行注释
可以换行
在多行有效*/
```

### 2.3 标识符和关键字

#### 标识符

在编程语言中，标识符是用户编程时使用的名字，变量、常量、函数、语句块都有名字。是用来标识某个实体的一个符号，是对变量名、函数名、标号和其他各种用户定义的对象命名。

C语言中标识符的命名规范：

- 标识符由字母（包括大写和小写）、数字和下划线（`_`）组成，并且首字母不能是数字。
- 不能把C的关键字作为用户的标识符，不能重复标识。
- 标识符长度是由机器上的编译系统决定的，一般的限制为8字符。
- 标识符对大小写敏感，即严格区分大小写。一般对变量名用小写，符号常量命名用大写。
- 标识符命名应做到"见名知意"。



#### 关键字

C语言的关键字，是C语言保留的一些有特殊作用词语。一共有32个关键字，

| 关键字   | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| auto     | 声明自动变量                                                 |
| double   | 声明双精度变量或函数                                         |
| typedef  | 用以给数据类型取别名                                         |
| register | 声明寄存器变量                                               |
| short    | 声明短整型变量或函数                                         |
| char     | 声明字符型变量或函数                                         |
| const    | 声明只读变量                                                 |
| static   | 声明静态变量int声明整型变量或函数                            |
| struct   | 声明结构体变量或函数                                         |
| unsigned | 声明无符号类型变量或函数                                     |
| volatile | 说明变量在程序执行中可被隐含地改变long声明长整型变量或函数   |
| union    | 声明共用数据类型                                             |
| signed   | 声明有符号类型变量或函数                                     |
| void     | 声明函数无返回值或无参数，声明无类型指针float声明浮点型变量或函数 |
| enum     | 声明枚举类型                                                 |
| extern   | 声明变量是在其他文件正声明                                   |
| if       | 条件语句                                                     |
| else     | 条件语句否定分支（与 if 连用）                               |
| switch   | 用于开关语句                                                 |
| case     | 开关语句分支                                                 |
| for      | 一种循环语句do循环语句的循环体                               |
| while    | 循环语句的循环条件                                           |
| goto     | 无条件跳转语句                                               |
| continue | 结束当前循环，开始下一轮循环break跳出当前循环                |
| default  | 开关语句中的"其他"分支                                       |
| sizeof   | 计算数据类型长度                                             |
| return   | 子程序返回语句（可以带参数，也可不带参数）循环条件           |



### 2.4 变量和常量

变量名在 C 语言里面属于标识符（identifier），命名有严格的规范。

#### 变量的声明

C 语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。

每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。

```
int height;
```

如果几个变量具有相同类型，可以在同一行声明。

```
int height, width;

// 等同于
int height;
int width;
```

注意，声明变量的语句必须以分号结尾。

一旦声明，变量的类型就不能在运行时修改。

#### 变量的赋值

C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。

变量的值应该与类型一致，不应该赋予不是同一个类型的值，比如`num`的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致。

赋值操作通过赋值运算符（`=`）完成。

变量的声明和赋值，也可以写在一行。

```c
int num;
num = 42;
```

```c
int num = 42;
```



```
多个相同类型变量的赋值，可以写在同一行。
int x = 1, y = 2;
```

注意，赋值表达式有返回值，等于等号右边的值。

由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。

```
int x, y, z, m, n;

x = y = z = m = n = 3;
```

上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为`n`赋值，然后依次为`m`、`z`、`y`和`x`赋值。

C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边，比如`x = 1`是合法的表达式，但是`1 = x`就会报错。

#### 变量的作用域

作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。

文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。

上面示例中，变量`x`是在文件顶层声明的，从声明位置开始的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数`main()`内部就可以读取这个变量。

```
int x = 1;

int main(void) {
  printf("%i\n", x);
}
```

块作用域（block scope）指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。

```
int a = 12;

if (a == 12) {
  int b = 99;
  printf("%d %d\n", a, b);  // 12 99
}

printf("%d\n", a);  // 12
printf("%d\n", b);  // 出错
```

代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。上面示例中，内层和外层都有一个变量`i`，每个作用域都会优先使用当前作用域声明的`i`。

```
{
  int i = 10;

  {
    int i = 20;
    printf("%d\n", i);  // 20
  }

  printf("%d\n", i);  // 10
}
```

#### 常量



**常量**是固定值，在程序执行期间不会改变。相比于变量，只不过常量的值在定义后不能进行修改。

整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

```c
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */


int myInt = 10;
long myLong = 100000L;
unsigned int myUnsignedInt = 10U;
```



#### 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点常量的实例：

```c
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */

float myFloat = 3.14f;
double myDouble = 3.14159;
```



#### 字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符                 |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |

```c
char myChar = 'a';
int myAsciiValue = (int) myChar; *// 将 myChar 转换为 ASCII 值 97*
```

#### 字符串常量

字符串字面值或常量是括在双引号 **" "** 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

```c
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"

字符串常量在内存中以 **null** 终止符 **\0** 结尾。例如：
char myString[] = "Hello, world!"; //系统对字符串常量自动加一个 '\0'
```



#### 定义常量

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。
2. 使用 **const** 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。

#### #define 预处理器

下面是使用 #define 预处理器定义常量的形式：

```
#define 常量名 常量值
```

下面的代码定义了一个名为 PI 的常量：

```
#define PI 3.14159
```

在程序中使用该常量时，编译器会将所有的 PI 替换为 3.14159。

具体请看下面的实例：

```c
#include <stdio.h>
#define LENGTH 10
#define WIDTH  5
#define NEWLINE '\n'
int main() {
    int area;
    area = LENGTH * WIDTH;
    printf("value of area : %d", area); 
    printf("%c", NEWLINE);
    return 0; 
}
value of area : 50
```

#### const 关键字

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```
const 数据类型 常量名 = 常量值;
```

下面的代码定义了一个名为MAX_VALUE的常量：

```
const int MAX_VALUE = 100;
```

在程序中使用该常量时，其值将始终为100，并且不能被修改。

const 声明常量要在一个语句内完成：

当上面的代码被编译和执行时，它会产生下列结果：

请注意，把常量定义为大写字母形式，是一个很好的编程习惯。

```c
#include <stdio.h>
int main() {
    const int  LENGTH = 10;
    const int  WIDTH  = 5;
    const char NEWLINE = '\n';
    int area;
    area = LENGTH * WIDTH;
    printf("value of area : %d", area);
    printf("%c", NEWLINE);
    return 0; 
}
value of area : 50
```



#### #define 与 const 区别

\#define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。

\#define 预处理指令和 const 关键字在定义常量时有一些区别：

- 替换机制：`#define` 是进行简单的文本替换，而 `const` 是声明一个具有类型的常量。`#define` 定义的常量在编译时会被直接替换为其对应的值，而 `const` 定义的常量在程序运行时会分配内存，并且具有类型信息。
- 类型检查：`#define` 不进行类型检查，因为它只是进行简单的文本替换。而 `const` 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。
- 作用域：`#define` 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 `const` 定义的常量具有块级作用域，只在其定义所在的作用域内有效。
- 调试和符号表：使用 `#define` 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 `const` 定义的常量会在符号表中有相应的条目，有助于调试和可读性。

### 2.5 输入和输出

当我们提到**输入**时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。

当我们提到**输出**时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。

#### 标准文件

C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。

| 标准文件 | 文件指针 | 设备     |
| :------- | :------- | :------- |
| 标准输入 | stdin    | 键盘     |
| 标准输出 | stdout   | 屏幕     |
| 标准错误 | stderr   | 您的屏幕 |

文件指针是访问文件的方式，本节将讲解如何从键盘上读取值以及如何把结果输出到屏幕上。

C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。

scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。

```c
#include <stdio.h> // 执行 printf() 函数需要该库 
int main() {
    printf("菜鸟教程");
    //显示引号中的内容    
    return 0; 
}
```

**实例解析：**

- 所有的 C 语言程序都需要包含 **main()** 函数。 代码从 **main()** 函数开始执行。
- **printf()** 用于格式化输出到屏幕。**printf()** 函数在 **"stdio.h"** 头文件中声明。
- **stdio.h** 是一个头文件 (标准输入输出头文件) and **#include** 是一个预处理命令，用来引入头文件。 当编译器遇到 **printf()** 函数时，如果没有找到 **stdio.h** 头文件，会发生编译错误。
- **return 0;** 语句用于表示退出程序。

#### %d 格式化输出整数

```c
#include <stdio.h> 
int main() {
    int testInteger = 5;
    printf("Number = %d", testInteger);
    return 0; }
Number = 5
```

在 printf() 函数的引号中使用 "%d" (整型) 来匹配整型变量 testInteger 并输出到屏幕。

#### %f 格式化输出浮点型数据

```c
#include <stdio.h>
int main() {
    float f;
    printf("Enter a number: ");
    // %f 匹配浮点型数据    scanf("%f",&f);    
    printf("Value = %f", f);
    return 0;
}
```



#### getchar() & putchar() 函数

**int getchar(void)** 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

**int putchar(int c)** 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：

```c
#include <stdio.h>
int main( ) {
    int c;
    printf( "Enter a value :");
    c = getchar( );
    printf( "\nYou entered: ");
    putchar( c );
    printf( "\n");
    return 0;
}
$./a.out
    Enter a value :runoob

        You entered: r
```

#### gets() & puts() 函数

**char \*gets(char \*s)** 函数从 **stdin** 读取一行到 **s** 所指向的缓冲区，直到一个终止符或 EOF。

**int puts(const char \*s)** 函数把字符串 s 和一个尾随的换行符写入到 **stdout**。



当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：

```c
#include <stdio.h>
int main( ) {
    char str[100];
    printf( "Enter a value :");
    gets( str );
    printf( "\nYou entered: ");
    puts( str );
    return 0;
}


$./a.out
Enter a value :runoob

You entered: runoob
```

#### scanf() 和 printf() 函数

**int scanf(const char \*format, ...)** 函数从标准输入流 **stdin** 读取输入，并根据提供的 **format** 来浏览输入。

**int printf(const char \*format, ...)** 函数把输出写入到标准输出流 **stdout** ，并根据提供的格式产生输出。

**format** 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：



代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：

```c
#include <stdio.h>
int main( ) {
    char str[100];
    int i;
    printf( "Enter a value :");
    scanf("%s %d", str, &i);
    printf( "\nYou entered: %s %d ", str, i);
    printf("\n");
    return 0;
}

$./a.out
Enter a value :runoob 123

You entered: runoob 123 
```

在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 "string integer"，如果您提供的是 "string string" 或 "integer integer"，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串。

### 2.6 预处理器

C 语言编译器在编译程序之前，会先使用预处理器处理代码。预处理指令一般放在代码的开头部分。每个预处理指令都以`#`开头，放在一行的行首。所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。

| 指令               | 作用                                                         |      |
| ------------------ | ------------------------------------------------------------ | ---- |
| #define            | 最常见的预处理指令，用来将指定的词替换成另一个词。           |      |
| `#undef`           | 用来取消已经使用`#define`定义的宏。                          |      |
| #include           | 用于编译时将其他源码文件，加载进入当前文件。                 |      |
| `#if...#endif`     | 用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。 |      |
| `#ifdef...#endif`  | 用于判断某个宏是否定义过。                                   |      |
| `#ifndef...#endif` | 用来判断，如果某个宏没有被定义过，则执行指定的操作。         |      |
| `#line`            | 用于覆盖预定义宏`__LINE__`，将其改为自定义的行号。后面的行将从`__LINE__`的新值开始计数。 |      |
| `#error`           | 用于让预处理器抛出一个错误，终止编译。                       |      |
| `#pragma`          | 用来修改编译器属性。                                         |      |

#### #define

`#define`是最常见的预处理指令，用来将指定的词替换成另一个词。第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。

`#define`指定将源码里面的`MAX`，全部替换成`100`。`MAX`就称为一个宏。

宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（`_`），且首字符不能是数字。

宏是原样替换，指定什么内容，就一模一样替换成什么内容。

`#define`允许多重替换，即一个宏可以包含另一个宏。

宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。

```
#define MAX 100
```

```
#define TWO 2
#define FOUR TWO*TWO
```

上面示例中，`FOUR`会被替换成`2*2`。

注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。

同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。

#### 带参数的宏

宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。

这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。

宏的参数也可以是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。

带参数的宏也可以嵌套，一个宏里面包含另一个宏。

```
#define SQUARE(X) X*X
```

```
// 替换成 z = 2*2;
z = SQUARE(2);
```

```
#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
#define QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
#define QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)
```





#### `#`运算符，`##`运算符

由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上`#`。

```
#define STR(x) #x

// 等同于 printf("%s\n", "3.14159");
printf("%s\n", STR(3.14159));
```

如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用`##`运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。

```
#define MK_ID(n) i##n
int MK_ID(1), MK_ID(2), MK_ID(3);
// 替换成
int i1, i2, i3;
```

#### 不定参数的宏

宏的参数还可以是不定数量的（即不确定有多少个参数），`...`表示剩余的参数。

注意，`...`只能替代宏的尾部参数。

```
#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__
```



#### #undef

`#undef`指令用来取消已经使用`#define`定义的宏。

有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用`#undef`取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而`#undef`的参数如果是不存在的宏，并不会报错。

```
#define LIMIT 400
#undef LIMIT
```



#### #include

`#include`指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。

形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。

形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。

`#include`最常见的用途，就是用来加载包含函数原型的头文件（后缀名为`.h`）

```
// 形式一
#include <foo.h> // 加载系统提供的文件

// 形式二
#include "foo.h" // 加载用户提供的文件

#include "/usr/local/lib/foo.h"
```



#### #if...#endif

`#if...#endif`指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。

`#if`后面的`0`，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。`#if 0`这种写法常用来当作注释使用，不需要的代码就放在`#if 0`里面。

`#if`后面的判断条件，通常是一个表达式。如果表达式的值不等于`0`，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。

`#if...#endif`之间还可以加入`#else`指令，用于指定判断条件不成立时，需要编译的语句。

```
#if 0
  const double pi = 3.1415; // 不会执行
#endif
```

如果有多个判断条件，还可以加入`#elif`命令。

```
#if HAPPY_FACTOR == 0
  printf("I'm not happy!\n");
#elif HAPPY_FACTOR == 1
  printf("I'm just regular\n");
#else
  printf("I'm extra happy!\n");
#endif
```

上面示例中，通过`#elif`指定了第二重判断。注意，`#elif`的位置必须在`#else`之前。如果多个判断条件皆不满足，则执行`#else`的部分。

没有定义过的宏，等同于`0`。因此如果`UNDEFINED`是一个没有定义过的宏，那么`#if UNDEFINED`为伪，而`#if !UNDEFINED`为真。

`#if`的常见应用就是打开（或关闭）调试模式。

上面示例中，通过将`DEBUG`设为`1`，就打开了调试模式，可以输出调试信息。

```
#define DEBUG 1

#if DEBUG
printf("value of i : %d\n", i);
printf("value of j : %d\n", j);
#endif
```





#### #ifdef...#endif

`#ifdef...#endif`指令用于判断某个宏是否定义过。

有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用`#define`定义一个空的宏。通过这个宏，判断库文件是否被加载了。

```
#define EXTRA_HAPPY

#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#endif
```

`#ifdef`可以与`#else`指令配合使用。

```
#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#else
  printf("I'm just regular\n");
#endif
```

`#ifdef...#else...#endif`可以用来实现条件加载。

```
#ifdef MAVIS
  #include "foo.h"
  #define STABLES 1
#else
  #include "bar.h"
  #define STABLES 2
#endif
```

#### defined 运算符

上一节的`#ifdef`指令，等同于`#if defined`。

```
#ifdef FOO
// 等同于
#if defined FOO
```

上面示例中，`defined`是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。

使用这种语法，可以完成多重判断。

```
#if defined FOO
  x = 2;
#elif defined BAR
  x = 3;
#endif
```

这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。

```
#if defined IBMPC
  #include "ibmpc.h"
#elif defined MAC
  #include "mac.h"
#else
  #include "general.h"
#endif
```

#### #ifndef...#endif

`#ifndef...#endif`指令跟`#ifdef...#endif`正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。

```
#ifdef EXTRA_HAPPY
  printf("I'm extra happy!\n");
#endif

#ifndef EXTRA_HAPPY
  printf("I'm just regular\n");
#endif
```

`#ifndef`常用于防止重复加载。举例来说，为了防止头文件`myheader.h`被重复加载，可以把它放在`#ifndef...#endif`里面加载。

```
#ifndef MYHEADER_H
  #define MYHEADER_H
  #include "myheader.h"
#endif
```

`#ifndef`等同于`#if !defined`。

#### 预定义宏

C 语言提供一些预定义的宏，可以直接使用。

- `__DATE__`：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。
- `__TIME__`：编译时间，格式为“hh:mm:ss”。
- `__FILE__`：当前文件名。
- `__LINE__`：当前行号。
- `__func__`：当前正在执行的函数名。该预定义宏必须在函数作用域使用。
- `__STDC__`：如果被设为1，表示当前编译器遵循 C 标准。
- `__STDC_HOSTED__`：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。
- `__STDC_VERSION__`：编译所使用的 C 语言版本，是一个格式为`yyyymmL`的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。

下面示例打印这些预定义宏的值。

```
#include <stdio.h>

int main(void) {
  printf("This function: %s\n", __func__);
  printf("This file: %s\n", __FILE__);
  printf("This line: %d\n", __LINE__);
  printf("Compiled on: %s %s\n", __DATE__, __TIME__);
  printf("C Version: %ld\n", __STDC_VERSION__);
}

/* 输出如下

This function: main
This file: test.c
This line: 7
Compiled on: Mar 29 2021 19:19:37
C Version: 201710

*/
```

#### #line

`#line`指令用于覆盖预定义宏`__LINE__`，将其改为自定义的行号。后面的行将从`__LINE__`的新值开始计数。

```
// 将下一行的行号重置为 300
#line 300
```

`#line`还可以改掉预定义宏`__FILE__`，将其改为自定义的文件名。

```
#line 300 "newfilename"
```

上面示例中，下一行的行号重置为`300`，文件名重置为`newfilename`。

#### #error

`#error`指令用于让预处理器抛出一个错误，终止编译。

```
#if __STDC_VERSION__ != 201112L
  #error Not C11
#endif
```

上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。

#### #pragma

`#pragma`指令用来修改编译器属性。

```
// 使用 C99 标准
#pragma c9x on
```

## 三、数据类型

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：

### 3.1 整型

| 类型           | 存储大小    | 值范围                                               |
| :------------- | :---------- | :--------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

### 3.2 浮点型

| 类型        | 存储大小 | 值范围                 | 精度        |
| :---------- | :------- | :--------------------- | :---------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位有效位  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位有效位 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位有效位 |

### 3.3 字符型

| 类型 | 存储大小 |
| :--- | :------- |
| char | 1 字节   |

### 3.4 类型修饰符

#### void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 类型          | 例子                          |
| :------------ | ----------------------------- |
| 函数返回为空  | void exit (int status);       |
| 函数参数为空  | int rand(void);               |
| 指针指向 void | void \*malloc( size_t size ); |

### 3.5 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。

C 语言中有两种类型转换：

- **隐式类型转换：**隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。
- **显式类型转换：**显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。

```c
// 隐式类型转换

int i = 10;
float f = 3.14;
double d = i + f; *// 隐式将int类型转换为double类型*

// 显式类型转换实例

double d = 3.14159;
int i = (int)d; *// 显式将double类型转换为int类型*
```

## 四、运算符

### 4.1 算术运算符

C 语言的算术运算符

| 运算符 | 描述                   |
| :----- | :--------------------- |
| `+`    | 加法                   |
| `-`    | 减法                   |
| `*`    | 乘法                   |
| `/`    | 整除                   |
| `%`    | 取模，整除后的余数     |
| `++`   | 自增运算，整数值增加 1 |
| `--`   | 自减运算，整数值减少 1 |

### 4.2 关系运算符

| 运算符 | 描述     |
| :----- | :------- |
| `==`   | 相等     |
| `!=`   | 不等     |
| `>`    | 大于     |
| `<`    | 小于     |
| `>=`   | 大于等于 |
| `<=`   | 小于等于 |



### 4.3 逻辑运算符

| 运算符 | 描述                     |
| :----- | :----------------------- |
| `&&`   | 逻辑与运算符。全真为真。 |
| `||`   | 逻辑或运算符。全假为假。 |
| `!`    | 逻辑非运算符。若真则假。 |

### 4.4 位运算符

位运算符作用于位，并逐位执行操作。

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| `&`    | 与运算符,当两个二进制位都为`1`，返回`1`                      |
| `|`    | 或运算符。两个二进制位只要有一个为`1`，就返回`1`             |
| `^`    | 逻辑非运算符。两个二进制位有且仅有一个为`1`，就返回`1`       |
| `～`   | 取反运算符,对每个二进制位取反                                |
| `<<`   | 左移运算符,左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用`0`填充。 |
| `>>`   | 右移运算符,左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用`0`填充。 |

### 4.5 赋值运算符

下表列出了 C 语言支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

### 4.6 其他运算符

| 运算符   | 描述           | 实例                                 |
| :------- | :------------- | :----------------------------------- |
| sizeof() | 返回变量的大小 | sizeof(a) 将返回 4，其中 a 是整数。  |
| &        | 取地址运算符   | &a; 将给出变量的实际地址。           |
| *        | 取值运算符     | *a; 将指向一个变量。                 |
| ? :      | 三元条件表达式 | 如果条件为真 ? 则值为 X : 否则值为 Y |

### 4.7 运算符优先级

运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

| 类别       | 运算符                            | 结合性   |
| :--------- | :-------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                 | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |
| 乘除       | * / %                             | 从左到右 |
| 加减       | + -                               | 从左到右 |
| 移位       | << >>                             | 从左到右 |
| 关系       | < <= > >=                         | 从左到右 |
| 相等       | == !=                             | 从左到右 |
| 位与 AND   | &                                 | 从左到右 |
| 位异或 XOR | ^                                 | 从左到右 |
| 位或 OR    | \|                                | 从左到右 |
| 逻辑与 AND | &&                                | 从左到右 |
| 逻辑或 OR  | \|\|                              | 从左到右 |
| 条件       | ?:                                | 从右到左 |
| 赋值       | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                 | 从左到右 |



## 五、控制语句

### 5.1 if语句

一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。

::: info 提示

C 语言把任何**非零**和**非空**的值假定为 **true**，把**零**或 **null** 假定为 **false**。

:::

C 语言中 **if** 语句的语法：

如果布尔表达式为 **true**，则 if 语句内的代码块将被执行。

```c
if(a==1)
{
   /* 如果布尔表达式为真将执行的语句 */
}
```



C 语言中 **if…else** 语句的语法：

一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为 false 时执行。

如果布尔表达式为 **true**，则执行 **if** 块内的代码。如果布尔表达式为 **false**，则执行 **else** 块内的代码。

```c
if(a==1)
{
   /* 如果布尔表达式为真将执行的语句 */
}
else
{
   /* 如果布尔表达式为假将执行的语句 */
}
```



C 语言中 **if…else if…else ** 语句的语法：

一个 **if 语句** 后可跟一个可选的 **else if 语句和 else语句**，else 语句在其他条件不满足时执行。

```c
if(a==1){
     /* 如果布尔表达式为真将执行的语句 */
}
else if(a==2){
     /* 如果布尔表达式为真将执行的语句 */
}
else{
     /* 如果布尔表达式为假将执行的语句 */
}
```

### 5.2 switch语句

一个 **switch** 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 **switch case** 进行检查。

C 语言中 **switch** 语句的语法：

```c
switch (expression) {
case constant - expression:
    statement(s);
    break; /* 可选的 */
case constant - expression:
    statement(s);
    break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */
default:                /* 可选的 */
    statement(s);
}
```

**switch** 语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 是一个常量表达式，必须是一个整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。

### 5.3 while循环

只要给定的条件为真，C 语言中的 **while** 循环语句会重复执行一个目标语句。

**condition** 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。

C 语言中 **while** 循环的语法：

```
while(1)
{
   statement(s);
}
```



### 5.4 do-while循环

不像 **for** 和 **while** 循环，它们是在循环头部测试循环条件。在 C 语言中，**do...while** 循环是在循环的尾部检查它的条件。

**do...while** 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。

C 语言中 **do...while** 循环的语法：

```
do
{
   statement(s);

}while( 1 );
```

请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。

如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。

### 5.5 for循环

**for** 循环允许您编写一个执行指定次数的循环控制结构。

C 语言中 **for** 循环的语法：

```c
for ( init; condition; increment ) {   
    statement(s); 
}
```

下面是 for 循环的控制流：

1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

### 5.6 break和continue语句

::: tip

break 和 continue 遵循**就近原则**

:::

C 语言中 **break** 语句有以下两种用法：

1. 当 **break** 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
2. 它可用于终止 **switch** 语句中的一个 case。

C 语言中 **break** 语句的语法：

```
break;
```



continue 会跳过当前循环中的代码，强迫开始下一次循环。

对于 **for** 循环，**continue** 语句执行后自增语句仍然会执行。对于 **while** 和 **do...while** 循环，**continue** 语句重新执行条件判断语句。

C 语言中 **continue** 语句的语法：

```
continue;
```



## 六、函数

函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C 标准库提供了大量的程序可以调用的内置函数

### 6.1 函数的定义和调用

#### 定义函数

C 语言中的函数定义的一般形式如下：

```c
int main( viod )
{
   /*函数体*/
}
```

在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：

```c
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) { /* 局部变量声明 */
    int result;
    if (num1 > num2) {
        result = num1;
    } else {
        result = num2;
    }
    return result;
}
```



#### 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

针对上面定义的函数 max()，以下是函数声明：

```c
int max(int num1, int num2);
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

```c
int max(int, int);
```



#### 调用函数

创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。

```c
#include <stdio.h> /* 函数声明 */
int max(int num1, int num2);
int main() { /* 局部变量定义 */
    int a = 100;
    int b = 200;
    int ret; /* 调用函数来获取最大值 */
    ret = max(a, b);
    printf("Max value is : %d\n", ret);
    return 0;
} 
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) { /* 局部变量声明 */
    int result;
    if (num1 > num2)
        result = num1;
    else
        result = num2;
    return result;
}

//Max value is : 200
```



### 6.2 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有两种向函数传递参数的方式：

| 调用类型 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| 传值调用 | 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 |
| 引用调用 | 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 |

默认情况下，C 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。

向函数传递参数的**传值调用**方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。

默认情况下，C 语言使用*传值调用*方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。函数 **swap()** 定义如下：

```c
/* 函数定义 */
void swap(int x, int y)
{
    int temp;

    temp = x; /* 保存 x 的值 */
    x = y;    /* 把 y 赋值给 x */
    y = temp; /* 把 temp 赋值给 y */

    return;
}
```

现在，让我们通过传递实际参数来调用函数 **swap()**：

通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。

```c
/* 函数定义 */
void swap(int *x, int *y)
{
    int temp;
    temp = *x;    /* 保存地址 x 的值 */
    *x = *y;      /* 把 y 赋值给 x */
    *y = temp;    /* 把 temp 赋值给 y */

    return;
}
```

现在，让我们通过引用传值来调用函数 **swap()**：

### 6.3 函数返回值



### 6.4 递归函数

递归指的是在函数的定义中使用函数自身的方法。

语法格式如下：

```c
void recursion() {
    statements;
    ......... recursion(); /* 函数调用自身 */
    .........
}
int main() { recursion(); }
```

### 6.5 函数指针

函数指针是指向函数的指针变量。

通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。

函数指针可以像一般函数一样，用于调用函数、传递参数。

函数指针变量的声明：

```c
typedef int (*fun_ptr)(int,int); 
// 声明一个指向同样参数、返回值的函数指针类型
```

以下实例声明了函数指针变量 p，指向函数 max：

```c
#include <stdio.h>  
int max(int x, int y) {    return x > y ? x : y; }  
int main(void) {    /* p 是函数指针 */    
    int (* p)(int, int) = & max; // &可以省略    
    int a, b, c, d;     
    printf("请输入三个数字:");    
    scanf("%d %d %d", & a, & b, & c); 
    /* 与直接调用函数等价，d = max(max(a, b), c) */    
    d = p(p(a, b), c);      
    printf("最大的数字是: %d\n", d);     
    return 0; 
}
// 请输入三个数字:1 2 3
// 最大的数字是: 3
```



### 6.6 回调函数

函数指针作为某个函数的参数

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

实例中 **populate_array()** 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。

实例中我们定义了回调函数 **getNextRandomValue()**，它返回一个随机值，它作为一个函数指针传递给 **populate_array()** 函数。

**populate_array()** 将调用 **10** 次回调函数，并将回调函数的返回值赋值给数组。

```c
#include <stdio.h>
#include <stdlib.h>
void populate_array(int* array, size_t arraySize, int (*getNextValue)(void)) {
    for (size_t i = 0; i < arraySize; i++)
        array[i] = getNextValue();
} // 获取随机值
int getNextRandomValue(void) { return rand(); }
int main(void) {
    int myarray[10]; /* getNextRandomValue
                        不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了
                        int , 而不是函数指针*/
    populate_array(myarray, 10, getNextRandomValue);
    for (int i = 0; i < 10; i++) {
        printf("%d ", myarray[i]);
    }
    printf("\n");
    return 0;
}
```



## 七、字符串和数组

### 7.1 数组的定义和初始化

C 语言支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

数组中的特定元素可以通过索引访问，第一个索引值为 **0**。

C 语言还允许我们使用指针来处理数组，这使得对数组的操作更加灵活和高效。

#### 声明数组

在 C 中要声明一个数组，需要指定元素的类型和元素的数量

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：

```
double balance[10];
```

现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

#### 初始化数组

在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

```c
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```



如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

```c
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```



下面是一个为数组中某个元素赋值的实例：

```c
balance[4] = 50.0;
```

上述的语句把数组中第五个元素的值赋为 50.0

所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。



#### 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```c
double salary = balance[9];
```

上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

```c
#include <stdio.h>  
int main () {   
    int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */   
    int i,j;    /* 初始化数组元素 */            
    for ( i = 0; i < 10; i++ )   {      
        n[ i ] = i + 100; /* 设置元素 i 为 i + 100 */   
    }      /* 输出数组中每个元素的值 */   
    for (j = 0; j < 10; j++ )   {      
        printf("Element[%d] = %d\n", j, n[j] );   
    }    
    return 0; 
}
```



#### 获取数组长度

数组长度可以使用 **sizeof** 运算符来获取数组的长度，例如：

```c
int numbers[] = {1, 2, 3, 4, 5};
int length = sizeof(numbers) / sizeof(numbers[0]);
```

```c
#include <stdio.h>

int main() {
    int array[] = {1, 2, 3, 4, 5};
    int length = sizeof(array) / sizeof(array[0]);

    printf("数组长度为: %d**\n**", length);

    return 0;
}

//使用宏定义：

#include <stdio.h>
#define LENGTH(array) (sizeof(array) / sizeof(array[0]))

int main() {
    int array[] = {1, 2, 3, 4, 5};
    int length = LENGTH(array);

    printf("数组长度为: %d**\n**", length);

    return 0;
}
//数组长度为: 5
```





#### 数组名

在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。

```c
int myArray[5] = {10, 20, 30, 40, 50};
```

在这里，myArray 是数组名，它表示整数类型的数组，包含 5 个元素。myArray 也代表着数组的地址，即第一个元素的地址。



数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。

我们可以使用&运算符来获取数组的地址，

```c
int myArray[5] = {10, 20, 30, 40, 50};
int *ptr = &myArray[0]; // 或者直接写作 int *ptr = myArray;
```

在上面的例子中，ptr 指针变量被初始化为 myArray 的地址，即数组的第一个元素的地址。



需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，例如在函数传递参数或遍历数组时：

```c
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]); *// 数组名arr被当作指针使用*
    }
}

int main() {
    int myArray[5] = {10, 20, 30, 40, 50};
    printArray(myArray, 5); *// 将数组名传递给函数*
        return 0;
}
```

在上述代码中，printArray 函数接受一个整数数组和数组大小作为参数，我们将 myArray 数组名传递给函数，函数内部可以像使用指针一样使用 arr 数组名。

### 7.2 多维数组

C 语言支持多维数组。

例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：

```c
int threedim[5][10][4];
```

#### 二维数组

多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组

其中，**type** 可以是任意有效的 C 数据类型，**arrayName** 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列

因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。

```c
int x[3][4];
```



#### 初始化二维数组

多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。

```c
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

内部嵌套的括号是可选的，下面的初始化与上面是等同的：

```c
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```



#### 访问二维数组元素

二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：

```c
int val = a[2][3];
```

上面的语句将获取数组中第 3 行第 4 个元素。您可以通过上面的示意图来进行验证。让我们来看看下面的程序，我们将使用嵌套循环来处理二维数组：

```c
#include <stdio.h>
int main() { /* 一个带有 5 行 2 列的数组 */
    int a[5][2] = {{0, 0}, {1, 2}, {2, 4}, {3, 6}, {4, 8}};
    int i, j; /* 输出数组中每个元素的值 */
    for (i = 0; i < 5; i++) {
        for (j = 0; j < 2; j++) {
            printf("a[%d][%d] = %d\n", i, j, a[i][j]);
        }
    }
    return 0;
}
```

如上所述，您可以创建任意维度的数组，但是一般情况下，我们创建的数组是一维数组和二维数组。



### 7.3 数组与指针的关系

组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。

因此，在下面的声明中

```c
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```c
double *p;
double balance[10];

p = balance;
```



使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：

```c
#include <stdio.h>
int main() { /* 带有 5 个元素的整型数组 */
    double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
    double* p;
    int i;
    p = balance; /* 输出数组中每个元素的值 */
    printf("使用指针的数组值\n");
    for (i = 0; i < 5; i++) {
        printf("*(p + %d) : %f\n", i, *(p + i));
    }
    printf("使用 balance 作为地址的数组值\n");
    for (i = 0; i < 5; i++) {
        printf("*(balance + %d) : %f\n", i, *(balance + i));
    }
    return 0;
}
```

在上面的实例中，p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。一旦我们有了 p 中的地址，***p** 将给出存储在 p 中相应地址的值，正如上面实例中所演示的。



### 7.4 字符串

在 C 语言中，字符串实际上是使用空字符 **\0** 结尾的一维字符数组。因此，**\0** 是用于标记字符串的结束。

**空字符（Null character**）又称结束符，缩写 **NUL**，是一个数值为 **0** 的控制字符，**\0** 是转义字符，意思是告诉编译器，这不是字符 **0**，而是空字符。

下面的声明和初始化创建了一个 **RUNOOB** 字符串。由于在数组的末尾存储了空字符 **\0**，所以字符数组的大小比单词 **RUNOOB** 的字符数多一个。

```c
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
```

依据数组初始化规则，您可以把上面的语句写成以下语句：

```c
char site[] = "RUNOOB";
```

其实，您不需要把 **null** 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 **\0** 放在字符串的末尾。让我们尝试输出上面的字符串：

```c
#include <stdio.h>
int main() {
    char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
    printf("菜鸟教程: %s\n", site);
    return 0;
}
```



C 中有大量操作字符串的函数：

| 函数            | 目的                                                         |
| :-------------- | :----------------------------------------------------------- |
| strcpy(s1, s2); | 复制字符串 s2 到字符串 s1。                                  |
| strcat(s1, s2); | 连接字符串 s2 到字符串 s1 的末尾。                           |
| strlen(s1);     | 返回字符串 s1 的长度。                                       |
| strcmp(s1, s2); | 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| strchr(s1, ch); | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。   |
| strstr(s1, s2); | 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

下面的实例使用了上述的一些函数：

```c
#include <stdio.h>
#include <string.h>
int main() {
    char str1[14] = "runoob";
    char str2[14] = "google";
    char str3[14];
    int len; /* 复制 str1 到 str3 */
    strcpy(str3, str1);
    printf("strcpy( str3, str1) :  %s\n", str3); /* 连接 str1 和 str2 */
    strcat(str1, str2);
    printf("strcat( str1, str2):   %s\n", str1); /* 连接后，str1 的总长度 */
    len = strlen(str1);
    printf("strlen(str1) :  %d\n", len);
    return 0;
}
```



## 八、指针

### 8.1 指针的基本概念

学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 **&** 运算符访问的地址，它表示了在内存中的一个地址。

请看下面的实例，它将输出定义的变量地址：

```c
#include <stdio.h>  
int main () {    
    int var_runoob = 10;    
    int *p;              
    // 定义指针变量    
    p = &var_runoob;    
    printf("var_runoob 变量的地址： %p\n", p);   
    return 0; 
}
```



#### 什么是指针？

指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var_name** 是指针变量的名称。用来声明指针的星号 ***** 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

```c
int* ip;    /* 一个整型的指针 */
double* dp; /* 一个 double 型的指针 */
float* fp;  /* 一个浮点型的指针 */
char* ch;   /* 一个字符型的指针 */
```

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

#### 如何使用指针？

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

```c
#include <stdio.h>
int main() {
    int var = 20; /* 实际变量的声明 */
    int* ip;      /* 指针变量的声明 */
    ip = &var;    /* 在指针变量中存储 var 的地址 */
    printf("var 变量的地址: %p\n", &var); /* 在指针变量中存储的地址 */
    printf("ip 变量存储的地址: %p\n", ip); /* 使用指针访问值 */
    printf("*ip 变量的值: %d\n", *ip);
    return 0;
}
```



#### C 中的 NULL 指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。

NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序

```c
#include <stdio.h>
int main() {
    int* ptr = NULL;
    printf("ptr 的地址是 %p\n", ptr);
    return 0;
}
```

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

```c
if (ptr)      /* 如果 p 非空，则完成 */
if (!ptr) /* 如果 p 为空，则完成 */
```



### 8.2 指针的运算

C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。

假设 **ptr** 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```
ptr++
```

在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

我们概括一下：

- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。



#### 递增一个指针

我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素

```c
#include <stdio.h>
const int MAX = 3;
int main() {
    int var[] = {10, 100, 200};
    int i, *ptr; /* 指针中的数组地址 */
    ptr = var;
    for (i = 0; i < MAX; i++) {
        printf("存储地址：var[%d] = %p\n", i, ptr);
        printf("存储值：var[%d] = %d\n", i, *ptr); /* 指向下一个位置 */
        ptr++;
    }
    return 0;
}
```



#### 递减一个指针

同样地，对指针进行递减运算，即把值减去其数据类型的字节数，如下所示：

```c
#include <stdio.h>
const int MAX = 3;
int main() {
    int var[] = {10, 100, 200};
    int i, *ptr; /* 指针中最后一个元素的地址 */
    ptr = &var[MAX - 1];
    for (i = MAX; i > 0; i--) {
        printf("存储地址：var[%d] = %p\n", i - 1, ptr);
        printf("存储值：var[%d] = %d\n", i - 1, *ptr); /* 指向下一个位置 */
        ptr--;
    }
    return 0;
}
```



#### 指针的比较

指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]，则把变量指针进行递增：

```c
#include <stdio.h>
const int MAX = 3;
int main() {
    int var[] = {10, 100, 200};
    int i, *ptr; /* 指针中第一个元素的地址 */
    ptr = var;
    i = 0;
    while (ptr <= &var[MAX - 1]) {
        printf("存储地址：var[%d] = %p\n", i, ptr);
        printf("存储值：var[%d] = %d\n", i, *ptr); /* 指向上一个位置 */
        ptr++;
        i++;
    }
    return 0;
}
```



### 8.3 指针和数组

C 指针数组是一个数组，其中的每个元素都是指向某种数据类型的指针。

指针数组存储了一组指针，每个指针可以指向不同的数据对象。

指针数组通常用于处理多个数据对象，例如字符串数组或其他复杂数据结构的数组。

用到了一个由 3 个整数组成的数组

```c
#include <stdio.h>
const int MAX = 3;
int main() {
    int var[] = {10, 100, 200};
    int i;
    for (i = 0; i < MAX; i++) {
        printf("Value of var[%d] = %d\n", i, var[i]);
    }
    return 0;
}
```



可能有一种情况，我们想要让数组存储指向 int 或 char 或其他数据类型的指针。

下面是一个指向整数的指针数组的声明：

```c
int *ptr[MAX];
```

在这里，把 **ptr** 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示：

```c
#include <stdio.h>
const int MAX = 3;
int main() {
    int var[] = {10, 100, 200};
    int i, *ptr[MAX];
    for (i = 0; i < MAX; i++) {
        ptr[i] = &var[i]; /* 赋值为整数的地址 */
    }
    for (i = 0; i < MAX; i++) {
        printf("Value of var[%d] = %d\n", i, *ptr[i]);
    }
    return 0;
}
```



您也可以用一个指向字符的指针数组来存储一个字符串列表，如下：

```c
#include <stdio.h>
const int MAX = 4;
int main() {
    const char* names[] = {
        "Zara Ali",
        "Hina Ali",
        "Nuha Ali",
        "Sara Ali",
    };
    int i = 0;
    for (i = 0; i < MAX; i++) {
        printf("Value of names[%d] = %s\n", i, names[i]);
    }
    return 0;
}
```



再看一个简单实例，我们首先声明了一个包含三个整数指针的指针数组 ptrArray，然后，我们将这些指针分别指向不同的整数变量 num1、num2 和 num3，最后，我们使用指针数组访问这些整数变量的值。

```c
#include <stdio.h>
int main() {
    int num1 = 10, num2 = 20, num3 = 30; // 声明一个整数指针数组，包含三个指针
    int* ptrArray[3];                    // 将指针指向不同的整数变量
    ptrArray[0] = &num1;
    ptrArray[1] = &num2;
    ptrArray[2] = &num3; // 使用指针数组访问这些整数变量的值
    printf("Value at index 0: %d\n", *ptrArray[0]);
    printf("Value at index 1: %d\n", *ptrArray[1]);
    printf("Value at index 2: %d\n", *ptrArray[2]);
    return 0;
}
```

指针数组在C中非常有用，特别是在处理具有不定数量元素的数据结构时，如动态分配的字符串数组或动态创建的结构体数组。



### 8.4 指针和函数

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：

```c
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

```c
#include <stdio.h>
int main() {
    int V;
    int* Pt1;
    int** Pt2;
    V = 100;    /* 获取 V 的地址 */
    Pt1 = &V;   /* 使用运算符 & 获取 Pt1 的地址 */
    Pt2 = &Pt1; /* 使用 pptr 获取值 */
    printf("var = %d\n", V);
    printf("Pt1 = %p\n", Pt1);
    printf("*Pt1 = %d\n", *Pt1);
    printf("Pt2 = %p\n", Pt2);
    printf("**Pt2 = %d\n", **Pt2);
    return 0;
}
```



C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。

下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：

```c
#include <stdio.h>
#include <time.h>

void getSeconds(unsigned long *par);

int main ()
{
  unsigned long sec;


  getSeconds( &sec );

  \* 输出实际值 
  printf("Number of seconds: %ld**\n**", sec );

  return 0;
}

void getSeconds(unsigned long *par)
{
  \* 获取当前的秒数 */
  *par = time( NULL );
  return;
}
```



能接受指针作为参数的函数，也能接受数组作为参数

```c
#include <stdio.h>

//函数声明
double getAverage(int* arr, int size);

int main() {
    //带有 5 个元素的整型数组
    int balance[5] = {1000, 2, 3, 17, 50};
    double avg;

    //传递一个指向数组的指针作为参数
    avg = getAverage(balance, 5);

    //输出返回值
    printf("Average value is: %f**\n**", avg);

    return 0;
}

double getAverage(int* arr, int size) {
    int i, sum = 0;
    double avg;

    for (i = 0; i < size; ++i) {
        sum += arr[i];
    }

    avg = (double)sum / size;

    return avg;
}
```



### 8.5 指针的指针

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：

```c
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

```c
#include <stdio.h>
int main() {
    int V;
    int* Pt1;
    int** Pt2;
    V = 100;    /* 获取 V 的地址 */
    Pt1 = &V;   /* 使用运算符 & 获取 Pt1 的地址 */
    Pt2 = &Pt1; /* 使用 pptr 获取值 */
    printf("var = %d\n", V);
    printf("Pt1 = %p\n", Pt1);
    printf("*Pt1 = %d\n", *Pt1);
    printf("Pt2 = %p\n", Pt2);
    printf("**Pt2 = %d\n", **Pt2);
    return 0;
}
```



## 九、结构体

### 9.1 结构体的定义和初始化

C 数组允许定义可存储相同类型数据项的变量，**结构**是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。

结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：

- Title
- Author
- Subject
- Book ID

#### 定义结构

结构体定义由关键字 **struct** 和结构体名组成，结构体名可以根据需要自行定义。

struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```c
struct tag {
  member-list
  member-list
  member-list  
  ...
} variable-list ;
```

**tag** 是结构体标签。

**member-list** 是标准的变量定义，比如 **int i;** 或者 **float f;**，或者其他有效的变量定义。

**variable-list** 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：

```c
struct Books
{
  char title[50];
  char author[50];
  char subject[100];
  int  book_id;
} book;
```

在一般情况下，**tag、member-list、variable-list** 这 3 部分至少要出现 2 个。以下为实例：

```c
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct
{
  int a;
  char b;
  double c;
} s1;

//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
  int a;
  char b;
  double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;

//也可以用typedef创建新类型
typedef struct
{
  int a;
  char b;
  double c;
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;
```

在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&s1，则是非法的。

结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

```c
//此结构体的声明包含了其他的结构体
struct COMPLEX
{
  char string[100];
  struct SIMPLE a;
};

//此结构体的声明包含了指向自己类型的指针
struct NODE
{
  char string[100];
  struct NODE *next_node;
};
```

如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：

```c
struct B;   //对结构体B进行不完整声明

//结构体A中包含指向结构体B的指针
struct A
{
  struct B *partner;
  //other members;
};

//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
  struct A *partner;
  //other members;
};
```



### 9.2 结构体的成员访问

和其它类型变量一样，对结构体变量可以在定义时指定初始值。

```c
#include <stdio.h>

struct Books
{
    char title[50];
    char author[50];
    char subject[100];
    int  book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};

int main()
{
    printf("title : %s**\n**author: %s**\n**subject: %s**\n**book_id: %d**\n**", book.title, book.author, book.subject, book.book_id);
}
```



#### 访问结构成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 **struct** 关键字来定义结构类型的变量。下面的实例演示了结构的用法：

```c
#include <stdio.h>
#include <string.h>

struct Books
{
    char title[50];
    char author[50];
    char subject[100];
    int  book_id;
};

int main( )
{
    struct Books Book1;     /*声明 Book1，类型为 Books */ 
    struct Books Book2;     /* 声明 Book2，类型为 Books */

    //Book1 详述
    strcpy( Book1.title, "C Programming");
    strcpy( Book1.author, "Nuha Ali");
    strcpy( Book1.subject, "C Programming Tutorial");
    Book1.book_id = 6495407;

    //Book2 详述 
    strcpy( Book2.title, "Telecom Billing");
    strcpy( Book2.author, "Zara Ali");
    strcpy( Book2.subject, "Telecom Billing Tutorial");
    Book2.book_id = 6495700;

    //输出 Book1 信息 
    printf( "Book 1 title : %s**\n**", Book1.title);
    printf( "Book 1 author : %s**\n**", Book1.author);
    printf( "Book 1 subject : %s**\n**", Book1.subject);
    printf( "Book 1 book_id : %d**\n**", Book1.book_id);

    //输出 Book2 信息
    printf( "Book 2 title : %s**\n**", Book2.title);
    printf( "Book 2 author : %s**\n**", Book2.author);
    printf( "Book 2 subject : %s**\n**", Book2.subject);
    printf( "Book 2 book_id : %d**\n**", Book2.book_id);

    return 0;
}
```



#### 结构作为函数参数

您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：

```c
#include <stdio.h>
#include <string.h>

struct Books {
    char title[50];
    char author[50];
    char subject[100];
    int book_id;
};

/* 函数声明 */
void printBook(struct Books book);
int main() {
    struct Books Book1; /* 声明 Book1，类型为 Books */
    struct Books Book2; /* 声明 Book2，类型为 Books */

    /* Book1 详述 */
    strcpy(Book1.title, "C Programming");
    strcpy(Book1.author, "Nuha Ali");
    strcpy(Book1.subject, "C Programming Tutorial");
    Book1.book_id = 6495407;

    /* Book2 详述 */
    strcpy(Book2.title, "Telecom Billing");
    strcpy(Book2.author, "Zara Ali");
    strcpy(Book2.subject, "Telecom Billing Tutorial");
    Book2.book_id = 6495700;

    /* 输出 Book1 信息 */
    printBook(Book1);

    /* 输出 Book2 信息 */
    printBook(Book2);

    return 0;
}
void printBook(struct Books book) {
    printf("Book title : %s**\n**", book.title);
    printf("Book author : %s**\n**", book.author);
    printf("Book subject : %s**\n**", book.subject);
    printf("Book book_id : %d**\n**", book.book_id);
}
```



### 9.3 结构体数组

### 9.4 结构体指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似

```c
struct Books *struct_pointer;
```

现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面

```c
struct_pointer = &Book1;
```

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符

```c
struct_pointer->title;
```

让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念

```c
#include <stdio.h>
#include <string.h>

struct Books {
    char title[50];
    char author[50];
    char subject[100];
    int book_id;
};

/* 函数声明 */
void printBook(struct Books* book);
int main() {
    struct Books Book1; /* 声明 Book1，类型为 Books */
    struct Books Book2; /* 声明 Book2，类型为 Books */

    /* Book1 详述 */
    strcpy(Book1.title, "C Programming");
    strcpy(Book1.author, "Nuha Ali");
    strcpy(Book1.subject, "C Programming Tutorial");
    Book1.book_id = 6495407;

    /* Book2 详述 */
    strcpy(Book2.title, "Telecom Billing");
    strcpy(Book2.author, "Zara Ali");
    strcpy(Book2.subject, "Telecom Billing Tutorial");
    Book2.book_id = 6495700;

    /* 通过传 Book1 的地址来输出 Book1 信息 */
    printBook(&Book1);

    /* 通过传 Book2 的地址来输出 Book2 信息 */
    printBook(&Book2);

    return 0;
}
void printBook(struct Books* book) {
    printf("Book title : %s**\n**", book->title);
    printf("Book author : %s**\n**", book->author);
    printf("Book subject : %s**\n**", book->subject);
    printf("Book book_id : %d**\n**", book->book_id);
}
```



### 9.5 结构体大小的计算

C 语言中，我们可以使用 **sizeof** 运算符来计算结构体的大小，**sizeof** 返回的是给定类型或变量的字节大小。

对于结构体，**sizeof** 将返回结构体的总字节数，包括所有成员变量的大小以及可能的填充字节。

```c
#include <stdio.h>

struct Person {
    char name[20];
    int age;
    float height;
};

int main() {
    struct Person person;
    printf("结构体 Person 大小为: %zu 字节**\n**", sizeof(person));
    return 0;
}
```

以上实例中，我们定义了一个名为 **Person** 的结构体，它包含了一个字符数组 **name**、一个整数 **age** 和一个浮点数 **height**。

在 **main** 函数中，我们声明了一个 **Person** 类型的变量 **person**，然后使用 **sizeof** 运算符来获取 **person** 结构体的大小。



**注意**，结构体的大小可能会受到编译器的优化和对齐规则的影响，编译器可能会在结构体中插入一些额外的填充字节以对齐结构体的成员变量，以提高内存访问效率。因此，结构体的实际大小可能会大于成员变量大小的总和，如果你需要确切地了解结构体的内存布局和对齐方式，可以使用 **offsetof** 宏和 **__attribute__((packed))** 属性等进一步控制和查询结构体的大小和对齐方式。



## 十、联合体和枚举

### 10.1 联合体

联合体也可以在内部定义很多种类型的变量，但是它与结构体不同的是，所以的变量共用同一个空间。

```c
union Object {   //定义一个联合体类型唯一不同的就是前面的union了
    int a;
    char b;
    float c;
};
```

```c
#include <stdio.h>

union Object {
    int a;
    char b;
    float c;
};

int main() {
    union Object object;
    object.a = 66;   //先给a赋值66
    printf("%d", object.b);   //访问b
}
```

我修改的是a啊，怎么b也变成66了？这是因为它们共用了内存空间，实际上我们先将a修改为66，那么就将这段内存空间上的值修改为了66，因为内存空间共用，所以当读取b时，也会从这段内存空间中读取一个char长度的数据出来，所以得到的也是66。

```c
int main() {
    union Object object;
    object.a = 128;
    printf("%d", object.b);
}
```

因为：128 = 10000000，所以用char读取后，由于第一位是符号位，于是就变成了-128。

那么联合体的大小又是如何决定的呢？

```c
union Object {
    int a;
    char b;
    float c;
};

int main() {
    printf("%lu", sizeof(union Object));
}
```

实际上，联合体的大小至少是其内部最大类型的大小，这里是int所以就是4，当然，当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。



### 10.2 枚举

最后我们来看一下枚举类型，枚举类型一般用于表示一些预设好的整数常量，比如我们风扇有低、中、高三个档位，我们总是希望别人使用我们预设好的这三个档位，而不希望使用其他的档位，因为我们风扇就只设计了这三个档位。

这时我们就可以告诉别人，我们的风扇有哪几个档位，这种情况使用枚举就非常适合。在我们的程序中，只能使用基本数据类型对这三种档位进行区分，这样显然可读性不够，别人怎么知道哪个代表哪个档位呢？而使用枚举就没有这些问题了：

```c
/**
 * 比如现在我们设计：
 * 1 = 低档位
 * 2 = 中档位
 * 3 = 高档位
 */
enum status {low = 1, middle = 2, high = 3};   //enum 枚举类型名称 {枚举 = 初始值, 枚举...}
```

我们可以创建多个自定义名称的枚举，命名规则和变量差不多。我们可以当每一个枚举对应一个整数值，这样的话，我们就不需要去记忆每个数值代表的是什么档位了，我们可以直接根据枚举的名称来进行分辨，是不是很方便？

使用枚举也非常地方便：

```c
enum status {low = 1, middle = 2, high = 3};

int main() {
    enum status a = low;   //和之前一样，直接定义即可，类型为enum + 枚举名称，后面是变量名称，值可以直接写对应的枚举
    printf("%d", a);
}
int main() {
    enum status a = high;
    if(a == low) {   //判断起来就方便多了
        printf("低档位");
    } else if (a == high){
        printf("高档位");
    } else {
        printf("中档位");
    }
}
```

当然也可以直接加入到`switch`语句中：

```c
int main() {
    enum status a = high;
    switch (a) {
        case low:
        case high:
        case middle:
        default: ;
    }
}
```

不过在枚举变量定义时需要注意：

```c
enum status {low, middle, high};   //如果不给初始值的话，那么会从第一个枚举开始，默认值为0，后续依次+1
```

所以这里的low就是0，middle就是1，high就是2了。

```c
enum status {low, middle = 6, high};   //这里我们给middle设定为6
```

这时low由于是第一个，所以还是从0开始，不过middle这里已经指定为6了，所以紧跟着的high初始值就是middle的值+1了，因此low现在是0，middle就是6，high就是7了。

### 10.3 typedef关键字

typedef关键字，这个关键字用于给指定的类型起别名。

```c
typedef int lbwnb;   //食用方式：typedef 类型名称 自定义类型别名
```

比如这里我们给int起了一个别名，那么现在我们不仅可以使用int来表示一个int整数，而且也可以使用别名作为类型名称了：

```c
#include <stdio.h>

typedef int lbwnb;

int main() {
    lbwnb i = 666;   //类型名称直接写成别名，实际上本质还是int
    printf("%d", i);
}
typedef const char * String;   //const char * 我们就起个名称为String表示字符串

int main() {
    String str = "Hello World!";  //是不是有Java那味了
    printf(str);
}
```

当然除了这种基本类型之外，包括指针、结构体、联合体、枚举等等都可以使用这个关键字来完全起别名操作：

```c
#include <stdio.h>

typedef struct test {
    int age;
    char name[10];
} Student;   //为了方便可以直接写到后面，当然也可以像上面一样单独声明

int main() {
    Student student = {18, "小明"};   //直接使用别名，甚至struct关键字都不用加了
}
```

在数据结构的学习总，typedef使用会更加地频繁。



## 十一、文件操作

本章我们将介绍 C 程序员如何创建、打开、关闭文本文件或二进制文件。

一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用。

### 11.1 文件的打开和关闭

#### 打开文件

您可以使用 **fopen( )** 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 **FILE** 的一个对象，类型 **FILE** 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：

```c
FILE *fopen( const char *filename, const char *mode );
```

在这里，**filename** 是字符串，用来命名文件，访问模式 **mode** 的值可以是下列值中的一个：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 打开一个已有的文本文件，允许读取文件。                       |
| w    | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |
| a    | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |
| r+   | 打开一个文本文件，允许读写文件。                             |
| w+   | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |
| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |

如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

```c
"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
```

#### 关闭文件

为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：

```c
 int fclose( FILE *fp );
```

如果成功关闭文件，**fclose( )** 函数返回零，如果关闭文件时发生错误，函数返回 **EOF**。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 **stdio.h** 中的常量。

C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。



### 11.2 文件的读写

#### 写入文件

下面是把字符写入到流中的最简单的函数：

```c
int fputc( int c, FILE *fp );
```

函数 **fputc()** 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 **EOF**。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：

```c
int fputs( const char *s, FILE *fp );
```

函数 **fputs()** 把字符串 **s** 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 **EOF**。您也可以使用 **int fprintf(FILE \*fp,const char \*format, ...)** 函数把一个字符串写入到文件中。尝试下面的实例：

> **注意：**请确保您有可用的 **tmp** 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。
>
> **/tmp** 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: **C:\tmp**、**D:\tmp**等。

```c
#include <stdio.h>
int main() {
    FILE* fp = NULL;
    fp = fopen("/tmp/test.txt", "w+");
    fprintf(fp, "This is testing for fprintf...\n");
    fputs("This is testing for fputs...\n", fp);
    fclose(fp);
}
```

当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 **test.txt**，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。

#### 读取文件

下面是从文件读取单个字符的最简单的函数：

```c
int fgetc( FILE * fp );
```

**fgetc()** 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 **EOF**。下面的函数允许您从流中读取一个字符串：

```c
char *fgets( char *buf, int n, FILE *fp );
```

函数 **fgets()** 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 **buf**，并在最后追加一个 **null** 字符来终止字符串。

如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 **int fscanf(FILE \*fp, const char \*format, ...)** 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。

```c
#include <stdio.h>
int main() {
    FILE* fp = NULL;
    char buff[255];
    fp = fopen("/tmp/test.txt", "r");
    fscanf(fp, "%s", buff);
    printf("1: %s\n", buff);
    fgets(buff, 255, (FILE*)fp);
    printf("2: %s\n", buff);
    fgets(buff, 255, (FILE*)fp);
    printf("3: %s\n", buff);
    fclose(fp);
}
```

首先，**fscanf()** 方法只读取了 **This**，因为它在后边遇到了一个空格。其次，调用 **fgets()** 读取剩余的部分，直到行尾。最后，调用 **fgets()** 完整地读取第二行。

#### 二进制 I/O 函数

下面两个函数用于二进制输入和输出：

```c
size_t fread(void* ptr, size_t size_of_elements, size_t number_of_elements,
             FILE* a_file);
size_t fwrite(const void* ptr, size_t size_of_elements,
              size_t number_of_elements, FILE* a_file);
```

这两个函数都是用于存储块的读写 - 通常是数组或结构体。

### 11.3 文件指针的定位



### 11.4 错误处理



## 参考三三

- [c|菜鸟教程]()
- [c|网道]()