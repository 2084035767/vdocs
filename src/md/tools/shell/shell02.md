# 二、基本知识

## 2.1 铺垫知识

### 注释

用来解释或说明代码，解释器不解释执行

- 单行注释：以`#`开头，整行注释（行首，行尾均可）
- 多行注释：以`:<<EOF`开头，到`EOF`结束

```bash
# echo "这是单行注释"

echo "后面是注释" # 我是单行注释

:<<EOF
echo '这是多行注释'
echo '这是多行注释'
echo '这是多行注释'
EOF
```

### shebang

在shell脚本中，`#!+解释器路径`来指定脚本的解释器，其中`#!`被称为shebang(也称为Hashbang)

常见shebang

```shell
# 指定 sh 解释器
#!/bin/sh
# 指定 bash 解释器
#!/bin/bash
# 自动在 PATH 环境变量中查找你指定的程序(推荐)
#!/usr/bin/env bash
```

### echo命令

`echo`命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。

| 参数 | 说明             |
| ---- | ---------------- |
| -n   | 取消末尾的回车符 |
| -e   | 开启转义         |

**输出普通字符串**

如果输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。

> 注意：在某些Shell环境中，echo命令默认会解释转义字符。
>
> 为了保持准确性，以下例子都使用`-e`参数。

```bash
echo "hello, world"
# Output: hello, world

echo -e "hello\nworld" # -e 开启转义
# Output: 
#	hello
#	world
```

**输出含转义的字符串**

```bash
echo -e "hello, \"world\""
# Output: hello, "world"
```

**输出含不换行符的字符串**

```bash
# 默认情况下，echo输出的文本末尾会有一个回车符。
echo "hello"
echo "world"
# Output: 
#  hello
#  world

echo -n "hello" # -n 取消末尾的回车符
echo "world"
# Output:
#	helloworld
```

**输出重定向至文件**

```bash
echo "test" > test.txt
```

**输出执行结果**

```bash
echo `pwd`
# Output:(当前目录路径)
```

### printf命令

`printf` 用于格式化输出字符串，类似与C语言中 printf 的使用。

`printf` 默认不会自动添加换行符，如果需要换行可以手动添加 `\n`。

**输出普通字符串**

```bash
printf "%d %s\n" 1 "hello"
# Output:1 hello

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出
printf "%s\n" hello world
# Output:
#	hello
#	world
```

**输出无参数**

```bash
# 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替
printf "%s and %d \n"
# Output:
#	and 0
```

**格式化输出**

```bash
printf "%s %s %s\n" a b c d e f g h i j
# Output:
#  a b c
#  d e f
#  g h i
#  j
```

**printf 的转义符**

| 序列    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| `\a`    | 警告字符，通常为 ASCII 的 BEL 字符                           |
| `\b`    | 后退                                                         |
| `\c`    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |
| `\f`    | 换页（formfeed）                                             |
| `\n`    | 换行                                                         |
| `\r`    | 回车（Carriage return）                                      |
| `\t`    | 水平制表符                                                   |
| `\v`    | 垂直制表符                                                   |
| `\\`    | 一个字面上的反斜杠字符                                       |
| `\ddd`  | 表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效         |
| `\0ddd` | 表示 1 到 3 位的八进制值字符                                 |

### type命令

`type`命令用来判断命令的来源。

```bash
# 内置命令
type echo
# Output: echo is a shell builtin

# 外部命令
type ls
# Output: ls is hashed (/bin/ls)
```

`type`命令本身也是内置命令。

```bash
type type
# Output: type is a shell builtin
```

**`-a`参数**

`-a`参数可以查看一个命令的所有定义

```bash
type -a echo
# Output: echo is shell builtin
# Output: echo is /usr/bin/echo
# Output: echo is /bin/echo
# echo 命令既是内置命令，也有对应的外部程序。
```

**`-t`参数**

`-t`参数可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）。

```bash
type -t bash
# Output: file
type -t if
# Output: keyword
```

### 分号

分号（`;`）是命令的结束符，使得一行可以放置多个命令。

> 注意：使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。

```bash
clear; ls
```

## 2.2 变量和变量类型

### 变量



**变量命名原则**

- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
- 中间不能有空格，可以使用下划线（_）。
- 不能使用标点符号。
- 不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。

**声明变量**

访问变量的两种语法：`${var}` 和 `$var`

变量名外面的花括号是可选的，加花括号是为了帮助解释器识别变量的边界。

> 注意：
>
> - 赋值符号两侧不能有空格
>
> - 未初始化变量的值为`null`值，表示未赋值（注意null值不等于零）。但是似乎它在算术计算中的值是零。

```bash
hell="word"
echo ${hello}
# Output: word
```

**只读变量**

使用 `readonly` 命令可以将变量定义为只读变量，只读变量的值不能被改变。

```bash
hello="word"
readonly hello; hello="bye"
# Output: read-only variable: hello
```

**删除变量**

使用 `unset` 命令可以删除变量。变量被删除后不能再次使用。

> 注意：`unset` 命令不能删除只读变量。

```bash
hello="word"
unset hello
echo ${hello}
# Output:（空）
```

### 输出变量、export 命令

用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用`export`命令。这样输出的变量，对于子 Shell 来说就是环境变量。

`export`命令用来向子 Shell 输出变量。

> 注意：子 Shell 如果修改继承的变量，不会影响父 Shell。

```bash
export NAME=hello
```



### 变量类型

`set`命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

- **局部变量**：局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。
- **环境变量**：环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 `export` 关键字，shell 脚本也可以定义环境变量。
- **shell变量**：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。

**常见的环境变量**

使用`env`命令或`printenv`命令，可以显示所有环境变量。

使用`printenv`命令或`echo`命令可以查看单个环境变量的值。注意：`printenv`命令后面的变量名，不用加前缀`$`。

|   变量    | 描述                                               |
| :-------: | -------------------------------------------------- |
|  `$HOME`  | 当前用户的用户目录                                 |
|  `$PATH`  | 用分号分隔的目录列表，shell 会到这些目录中查找命令 |
|  `$PWD`   | 当前工作目录                                       |
|  `$BASH`  | Bash二进制程序文件的路径                           |
| `$RANDOM` | 0 到 32767 之间的整数                              |
|  `$UID`   | 数值类型，当前用户的用户 ID                        |
|  `$PS1`   | 主要系统输入提示符                                 |
|  `$PS2`   | 次要系统输入提示符                                 |



### 变量的默认值

Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。

```bash
${varname:-word}
:<<EOF
如果变量 varname 存在且不为空，则返回它的值，否则返回 word。它的目的是返回一个默认值。 
EOF
。

${varname:=word}
:<<EOF
如果变量 varname 存在且不为空，则返回它的值，否则将它设为 word，并且返回 word。
EOF


${varname:+word}
:<<EOF
如果变量名存在且不为空，则返回 word，否则返回空值。它的目的是测试变量是否存在。
EOF


${varname:?message}
:<<EOF
如果变量 varname 存在且不为空，则返回它的值，否则打印出 varname: message ，并中断脚本的执行。如果省略了 message ，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义。
EOF
```

上面四种语法如果用在脚本中，变量名的部分可以用数字`1`到`9`，表示脚本的参数。

```bash
filename=${1:?"filename missing."}
```



### declare 命令

`declare`命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。

> 提示：
>
> - `declare`命令如果用在函数中，声明的变量只在函数内部有效，等同于`local`命令。
>
> - 不带任何参数时，`declare`命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的`set`命令。

它的语法形式如下。

```bash
declare OPTION VARIABLE=value
```

`declare`命令的主要参数（OPTION）如下。

- `-a`：声明数组变量。
- `-f`：输出所有函数定义。
- `-F`：输出所有函数名。
- `-i`：声明整数变量。
- `-l`：声明变量为小写字母。
- `-p`：查看变量信息。
- `-r`：声明只读变量。
- `-u`：声明变量为大写字母。
- `-x`：该变量输出为环境变量。



## 2.3 表达式和运算符

### 算术表达式

`((...))`语法可以进行整数的算术运算。

> 注意：这个语法不返回值。只要算术结果不是`0`，命令就算执行成功。如果算术结果为`0`，命令就算执行失败。

```bash
((a = 5 + 5))
echo $a
# Output: 10

# 支持使用C风格操作符来处理变量
(( a++ ))
echo $a
# Output: 11

# ((...)) 会自动忽略内部的空格
((2+2))
# 等同于 (( 2 + 2 ))

# 算数结果是 0，环境变量 $? 为 1 ，表示命令执行失败。
(( 3 - 3 ))
echo $?
# Output: 1
```

**算术表达式**

在`((...))`前面加上美元符号`$((...))`，使其变成算术表达式，返回算术运算的值。

> 注意：
>
> - `$((...))`的圆括号之中，变量名之前加不加上`$`，均可。
>
> - 在`$((...))`里面使用字符串，会 Bash 视为变量名。如不存在此变量，Bash 会视为空值 0 ，因此不会报错。
>
> - 在`$((...))`里面使用变量且为字符串，Bash 就会视该变量的字符串为变量。这使得有可能写出动态替换的代码。

```bash
echo $((2 + 2))
# Output: 4

# $((...)) 内部可以用圆括号改变运算顺序
echo $(( (2 + 3) * 4 ))
# Output: 20

# $((...)) 结构支持嵌套
echo $(((5**2) * 3))
# Output: 75
# 等同于
echo $(($((5**2)) * 3))
# Output: 75

# 这个语法只能计算整数，否则会报错
echo $((1.5 + 1))
# Output: bash: 语法错误

# 变量 a 的值是 b，而 b 也会被看作变量名
a=b
b=3
echo $(( a + 2 ))
# Output: 5
```

**其他运算**

```bash
# 三元运算
# 算术表达式支持三元运算
a = 1
echo $((a == 1?b:c ))
# Output: 0

# 赋值运算
# 算术表达式支持赋值运算
a = 1
echo $((a += 1))
# Output: 2

# 求值运算
# 逗号 , 在其内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值
echo $((a = 1 + 2, 3 * 4))
# Output: 12
```



**数值的进制**

Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。

- `number`：没有任何特殊表示法的数字是十进制数（以10为底）。
- `0number`：八进制数。
- `0xnumber`：十六进制数。
- `base#number`：`base`进制的数。



```bash
# 0xff 是十六进制数，
echo $((0xff))
255

# 2#11111111 是二进制数。
echo $((2#11111111))
255
```

### expr 命令

`expr`命令支持算术运算，可以不使用`((...))`语法。

> 注意：数字和运算符有空格，不然输出会错

```bash
expr 3 + 2
# Output: 5

# 变量运算
$ a=3
$ expr $a + 2
# Output: 5

# expr 命令不支持非整数参数
$ expr 3.5 + 2
# Output: expr: 非整数参数
```



### let 命令

`let`命令用于将算术运算的结果，赋予一个变量。

```bash
let x=2+3
echo $x
# Output: 5
```



### 算术运算符

| 运算符 | 说明         |
| ------ | ------------ |
| +      | 加法         |
| -      | 减法         |
| *      | 乘法         |
| /      | 除法（整除） |
| %      | 取余         |
| =      | 赋值         |



### 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

使用格式：`[ $a -eq $b ]`

| 运算符 | 说明                                                  |
| ------ | ----------------------------------------------------- |
| `-eq`  | 检测两个数是否相等，相等返回 true。                   |
| `-ne`  | 检测两个数是否相等，不相等返回 true。                 |
| `-gt`  | 检测左边的数是否大于右边的，如果是，则返回 true。     |
| `-lt`  | 检测左边的数是否小于右边的，如果是，则返回 true。     |
| `-ge`  | 检测左边的数是否大于等于右边的，如果是，则返回 true。 |
| `-le`  | 检测左边的数是否小于等于右边的，如果是，则返回 true。 |



### 逻辑运算符

Shell 的逻辑运算符

| 运算符  | 说明                      |
| ------- | ------------------------- |
| `&&`    | 逻辑的与（AND）等同于`-o` |
| `| |`   | 逻辑的或（OR）等同于`-a`  |
| `<`     | 小于                      |
| `>`     | 大于                      |
| `<=`    | 小于或相等                |
| `>=`    | 大于或相等                |
| `==`    | 相等                      |
| `!=`    | 不相等                    |
| `!`     | 逻辑否                    |
| `a?b:c` | 三元条件运算符            |



### 二进制位运算符

| 运算符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `<<`   | 位左移运算，把一个数字的所有位向左移动指定的位。             |
| `\>>`  | 位右移运算，把一个数字的所有位向右移动指定的位。             |
| `&`    | 位的“与”运算，对两个数字的所有位执行一个`AND`操作。          |
| `|`    | 位的“或”运算，对两个数字的所有位执行一个`OR`操作。           |
| `~`    | 位的“否”运算，对一个数字的所有位取反。                       |
| `^`    | 位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。 |



### 字符串运算符

常用的字符串运算符

使用格式：`[-z $a ]`

| 运算符 | 说明                                                  |
| ------ | ----------------------------------------------------- |
| `=`    | 检测两个字符串是否相等，相等返回 true。               |
| `!=`   | 检测两个字符串是否相等，不相等返回 true。             |
| `-z`   | 检测字符串长度是否为 0，为 0 返回 true。              |
| `-n`   | 检测字符串长度是否为 0，不为 0 返回 true。            |
| `str`  | 检测字符串是否为空，不为空返回 true。使用方法`[ $a ]` |



### 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

| 操作符    | 说明                                                         | 举例                        |
| --------- | ------------------------------------------------------------ | --------------------------- |
| `-b file` | 检测文件是否是块设备文件，如果是，则返回 true。              | `[ -b $file ]` 返回 false。 |
| `-c file` | 检测文件是否是字符设备文件，如果是，则返回 true。            | `[ -c $file ]` 返回 false。 |
| `-d file` | 检测文件是否是目录，如果是，则返回 true。                    | `[ -d $file ]` 返回 false。 |
| `-f file` | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | `[ -f $file ]` 返回 true。  |
| `-g file` | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | `[ -g $file ]` 返回 false。 |
| `-k file` | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | `[ -k $file ]`返回 false。  |
| `-p file` | 检测文件是否是有名管道，如果是，则返回 true。                | `[ -p $file ]` 返回 false。 |
| `-u file` | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | `[ -u $file ]` 返回 false。 |
| `-r file` | 检测文件是否可读，如果是，则返回 true。                      | `[ -r $file ]` 返回 true。  |
| `-w file` | 检测文件是否可写，如果是，则返回 true。                      | `[ -w $file ]` 返回 true。  |
| `-x file` | 检测文件是否可执行，如果是，则返回 true。                    | `[ -x $file ]` 返回 true。  |
| `-s file` | 检测文件是否为空（文件大小是否大于 0），不为空返回 true。    | `[ -s $file ]` 返回 true。  |
| `-e file` | 检测文件（包括目录）是否存在，如果是，则返回 true。          | `[ -e $file ]` 返回 true。  |
