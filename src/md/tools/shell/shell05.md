# 五、脚本编写和调试

## 5.1 输入和输出重定向

**标准输入、输出和错误**

使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。

Bash 接收输入，并以字符序列或 **字符流** 的形式产生输出。这些流能被重定向到文件或另一个流中。

有三个文件描述符：

| 代码 | 描述符   | 描述         |
| ---- | -------- | ------------ |
| `0`  | `stdin`  | 标准输入     |
| `1`  | `stdout` | 标准输出     |
| `2`  | `stderr` | 标准错误输出 |



### 文件重定向

重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：

| Operator | Description                                                  |
| -------- | ------------------------------------------------------------ |
| `>`      | 重定向输出                                                   |
| `&>`     | 重定向输出和错误输出                                         |
| `&>>`    | 以附加的形式重定向输出和错误输出                             |
| `<`      | 重定向输入                                                   |
| `<<`     | [Here 文档](http://tldp.org/LDP/abs/html/here-docs.html)语法 |
| `<<<`    | [Here 字符串](http://www.tldp.org/LDP/abs/html/x17837.html)  |



以下是一些使用重定向的例子：

```bash
# ls的结果将会被写到list.txt中
ls -l > list.txt

# 将输出附加到list.txt中
ls -a >> list.txt

# 所有的错误信息会被写到errors.txt中
grep da * 2> errors.txt

# 从errors.txt中读取输入
less < errors.txt
```

**`/dev/null` 文件**

`/dev/null `是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

```bash
$ command > /dev/null
# 屏蔽 stdout 和 stderr
$ command > /dev/null 2>&1
```



### read 命令

|                |                                                              |
| -------------- | ------------------------------------------------------------ |
| `-t`           | 设置了超时的秒数。环境变量`TMOUT`也可以起到同样作用。        |
| `-p`           | 指定用户输入的提示信息。                                     |
| `-a`           | 把用户的输入赋值给一个数组，从零号位置开始。                 |
| `-n`           | 指定只读取若干个字符作为变量值，而不是整行读取。             |
| `-e`           | 允许用户输入的时候，使用`readline`库提供的快捷键。           |
| `-d delimiter` | 定义字符串`delimiter`的第一个字符作为用户输入的结束，而不是一个换行符。 |
| `-r`           | raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。       |
| `-s`           | 使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。 |
| `-u fd`        | 使用文件描述符`fd`作为输入。                                 |

`read`命令将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。（`$`表示用户标识符，详细见 Linux 一章）

```bash
echo -n "输入一些文本 > "
read text
echo "你的输入：$text"

# read 可以接受用户输入的多个值
# Output: 
$ bash demo.sh
$ 输入一些文本 > 你好，世界
$ 你的输入：你好，世界
```

**多变量赋值**

- 如果用户的输入项少于`read`命令给出的变量数目，那么额外的变量值为空。
- 如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。
- 如果`read`命令之后没有定义变量名，那么环境变量`REPLY`会包含所有的输入。

```bash
#!/bin/bash
# read-single: read multiple values into default variable
echo -n "Enter one or more values > "
read
echo "REPLY = '$REPLY'"
# Output: 
$ read-single
$ Enter one or more values > a b c d
$ REPLY = 'a b c d'
```

**读取文件**

`read`命令除了读取键盘输入，可以用来读取文件

> 解读：通过`read`命令，读取一个文件的内容。`done`命令后面的定向符`<`，将文件内容导向`read`命令，每次读取一行，存入变量`myline`，直到文件读取完毕。

```bash
#!/bin/bash

filename='/etc/hosts'

while read myline
do
  echo "$myline"
done < $filename
```



**IFS 变量**

通过自定义环境变量`IFS`（内部字段分隔符，Internal Field Separator），修改`read`命令读取的值的分隔标志。

`IFS`的默认值是空格、Tab 符号、换行符号，通常取第一个（即空格）。

如果把`IFS`定义成冒号（`:`）或分号（`;`），就可以分隔以这两个符号分隔的值，这对读取文件很有用。



## 5.2 脚本的编写和执行

### 脚本的编写

1. 创建脚本文件：使用文本编辑器创建一个新文件并命名。通常，Shell脚本文件的扩展名为`.sh`，但这不是强制要求。
2. 添加脚本命令：在脚本文件中添加Shell命令。Shell脚本是一系列按顺序执行的命令。你可以使用任何支持的Shell语法和命令来编写脚本。
3. 保存脚本文件：保存你的脚本文件。
4. 赋予执行权限：在执行脚本之前，你需要给脚本文件赋予执行权限。在终端中，使用`chmod`命令可以为脚本文件添加执行权限。



**交互模式**

在交互模式下可以输入 Linux 命令，解释器会立即执行。

shell 处于交互模式下：

```bash
user@host:~$
```



**非交互模式**

在非交互模式下，shell 从文件或者管道中读取命令并执行。当 shell 解释器执行完文件，shell 进程终止，并回到父进程。

 shell 以非交互模式运行：

```bash
sh /path/to/script.sh
bash /path/to/script.sh
source /path/to/script.sh
./path/to/script.sh
```



**执行自定义脚本文件**

通过`chmod`命令给文件添加可执行的权限，来直接执行脚本文件

```bash
chmod +x /path/to/test.sh # 使脚本具有执行权限
/path/to/test.sh
```



## 5.3 调试Shell脚本

### Debug

如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：

```bash
#!/bin/bash options
```

options 是一些可以改变 shell 行为的选项。

| 参数 | 说明                                                       |
| ---- | ---------------------------------------------------------- |
| `-f` | 禁止文件名展开（globbing）                                 |
| `-i` | 让脚本以 *交互* 模式运行                                   |
| `-n` | 读取命令，但不执行（语法检查）                             |
| `-t` | 执行完第一条命令后退出                                     |
| `-v` | 在执行每条命令前，向`stderr`输出该命令                     |
| `-x` | 在执行每条命令前，向`stderr`输出该命令以及该命令的扩展参数 |

### `set`命令

用来修改子 Shell 环境的运行参数，即定制环境。

| 参数         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| -u           | 执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。          |
| -x           | 用来在运行结果之前，先输出执行的那一行命令。                 |
| -e           | 使得脚本只要发生错误，就终止执行。                           |
| -o pipefail  | `set -e`有一个例外情况，就是不适用于管道命令。只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。 |
| -E           | 可以纠正设置了`-e`参数，会导致函数内的错误不会被`trap`命令捕获这个行为，使得函数也能继承`trap`命令。 |
| -n           | 不运行命令，只检查语法是否正确。                             |
| -f           | 表示不对通配符进行文件名扩展。可以使用`set +f`关闭。         |
| -v           | 表示打印 Shell 接收到的每一行输入。可以使用`set +v`关闭。    |
| -o noclobber | 防止使用重定向运算符`>`覆盖已经存在的文件。                  |

**`set` 命令总结**

上面重点介绍的`set`命令的几个参数，一般都放在一起使用。

> 建议：两种写法都放在所有 Bash 脚本的头部。

```bash
# 写法一
set -Eeuxo pipefail

# 写法二
set -Eeux
set -o pipefail

# 命令行传入这些参数
$ bash -euxo pipefail script.sh
```

### shopt 命令

`shopt`命令用来调整 Shell 的参数，跟`set`命令的作用很类似。

区别：`set`是从 Ksh 继承的，属于 POSIX 规范的一部分，而`shopt`是 Bash 特有的。

```bash
# shopt 可以查看所有参数，以及它们各自打开和关闭的状态
$ shopt

# shopt 命令后面跟着参数名，可以查询该参数是否打开
$ shopt globstar
# Output: globstar  off
```

 

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| `-s` | 用来打开某个参数。                                           |
| `-u` | 用来关闭某个参数。                                           |
| `-q` | 也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态（`$?`）表示查询结果。如果状态为`0`，表示该参数打开；如果为`1`，表示该参数关闭。 |

**`bash`的`-x`参数**

`bash`的`-x`参数可以在执行每一行命令之前，打印该命令。一旦出错，这样就比较容易追查。



**用于除错的环境变量**

| 环境变量      | 作用                                       |
| ------------- | ------------------------------------------ |
| `LINENO`      | 返回它在脚本里面的行号。                   |
| `FUNCNAME`    | 返回一个数组，内容是当前的函数调用堆栈。   |
| `BASH_SOURCE` | 返回一个数组，内容是当前的脚本调用堆栈。   |
| `BASH_LINENO` | 返回一个数组，内容是每一轮调用对应的行号。 |



### 临时文件的安全问题

生成临时文件应该遵循下面的规则。

> - 创建前检查文件是否已经存在。
> - 确保临时文件已成功创建。
> - 临时文件必须有权限的限制。
> - 临时文件要使用不可预测的文件名。
> - 脚本退出时，要删除临时文件（使用`trap`命令）。

### mktemp 命令

`mktemp`命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。

直接运行`mktemp`命令，就能生成一个临时文件。

**`mktemp`命令的操作**

```bash
# 生成一个临时文件
$ mktemp
# Output: /tmp/tmp.4GcsWSG4vj

# mktemp 命令后面最好使用 OR 运算符，保证创建失败时退出脚本
TMPFILE=$(mktemp) || exit 1
echo "Our temp file is $TMPFILE"

# 使用trap命令指定退出时的清除操作
trap 'rm -f "$TMPFILE"' EXIT

TMPFILE=$(mktemp) || exit 1
echo "Our temp file is $TMPFILE"
```



**`mktemp `命令的参数**

| 参数     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| `-d`参   | 可以创建一个临时目录。                                       |
| `-p`参   | 可以指定临时文件所在的目录。                                 |
| `-t`参数 | 可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的`X`字符，表示随机字符，建议至少使用六个`X`。默认的文件名模板是`tmp.`后接十个随机字符。 |



### trap 命令

`trap`命令用来在 Bash 脚本中响应系统信号。

最常见的系统信号就是 SIGINT（中断），即按 Ctrl + C 所产生的信号。`trap`命令的`-l`参数，可以列出所有的系统信号。

`trap`命令响应`EXIT`信号的写法如下

```bash
# 脚本遇到 EXIT 信号时，就会执行 rm -f "$TMPFILE"
$ trap 'rm -f "$TMPFILE"' EXIT
```



trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。

> 注意：`trap`命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。

```bash
#!/bin/bash

trap 'rm -f "$TMPFILE"' EXIT

TMPFILE=$(mktemp) || exit 1
ls /etc > $TMPFILE
if grep -qi "kernel" $TMPFILE; then
  echo 'find'
fi
```



如果`trap`需要触发多条命令，可以封装一个 Bash 函数。

```bash
function egress {
  command1
  command2
  command3
}

trap egress EXIT
```

